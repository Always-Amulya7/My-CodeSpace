{
  "metadata": {
    "totalProblems": 17,
    "lastUpdated": "2026-01-13T15:46:07.363Z",
    "breakdown": {
      "Codechef": {
        "total": 0,
        "Easy": 0,
        "Medium": 0,
        "Hard": 0
      },
      "Gfg": {
        "total": 1,
        "Easy": 1,
        "Medium": 0,
        "Hard": 0
      },
      "Leetcode": {
        "total": 13,
        "Easy": 4,
        "Medium": 6,
        "Hard": 3
      },
      "Hackerrank": {
        "total": 3,
        "Easy": 0,
        "Medium": 3,
        "Hard": 0
      }
    }
  },
  "problems": [
    {
      "id": "gfg-easy-decision-making-in-java",
      "platform": "Gfg",
      "difficulty": "Easy",
      "problemName": "Decision Making in Java",
      "language": "java",
      "files": {
        "code": "class Solution {\n     static String compareNM(int n, int m){\n        if(n<m){\n            return \"lesser\";\n        }\n        else if(n==m){\n            return \"equal\";\n        }\n        else{\n            return \"greater\";\n        }\n        \n    }\n }",
        "readme": "Decision_Making_Javaif_Else_Switch_Break_Continue_Jump\n\nDecision Making in Java\nDifficulty: BasicAccuracy: 60.12%Submissions: 208K+Points: 1\n\nGiven two integers, nÂ and m. The task is to check the relation between n and m. Return \"lesser\" if n < m,Â  \"equal\" if n == m, and \"greater\" if n > m.\n\nExamples :\n\n\nInput: n = 4, m = 8\nOutput: lesser\nExplanation: 4 < 8 so print 'lesser'.\nInput: n = 8, m = 8\nOutput: equal\nExplanation: 8 = 8 so print 'equal'.\nInput: n = 8, m = 4\nOutput: greater\nExplanation: 8 > 4 so print 'greater'.\n\nConstraints:\n-109 <= m , n <= 109\n\n\nTry more examples\nExpected Complexities\nTopic Tags\nRelated Articles\nReport An Issue\nIf you are facing any issue on this page. Please let us know.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-12-29T08:07:30.000Z"
    },
    {
      "id": "hackerrank-medium-java-date-and-time",
      "platform": "Hackerrank",
      "difficulty": "Medium",
      "problemName": "Java Date and Time",
      "language": "java",
      "files": {
        "code": "import java.io.*;\nimport java.math.*;\nimport java.security.*;\nimport java.text.*;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.function.*;\nimport java.util.regex.*;\nimport java.util.stream.*;\nimport static java.util.stream.Collectors.joining;\nimport static java.util.stream.Collectors.toList;\n\nclass Result {\n\n    /*\n     * Complete the 'findDay' function below.\n     *\n     * The function is expected to return a STRING.\n     * The function accepts following parameters:\n     *  1. INTEGER month\n     *  2. INTEGER day\n     *  3. INTEGER year\n     */\n\n    public static String findDay(int month, int day, int year) {\n    Calendar calendar = Calendar.getInstance();\n    calendar.set(year, month - 1, day);\n    var dayOfWeek = calendar.get(calendar.DAY_OF_WEEK);\n    String[] names = new String[] {\"SUNDAY\", \"MONDAY\", \"TUESDAY\", \"WEDNESDAY\", \"THURSDAY\", \"FRIDAY\", \"SATURDAY\"};\n    return names[dayOfWeek - 1];\n}\n\n}\n\npublic class Solution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(\"OUTPUT_PATH\")));\n\n        String[] firstMultipleInput = bufferedReader.readLine().replaceAll(\"\\\\s+$\", \"\").split(\" \");\n\n        int month = Integer.parseInt(firstMultipleInput[0]);\n\n        int day = Integer.parseInt(firstMultipleInput[1]);\n\n        int year = Integer.parseInt(firstMultipleInput[2]);\n\n        String res = Result.findDay(month, day, year);\n\n        bufferedWriter.write(res);\n        bufferedWriter.newLine();\n\n        bufferedReader.close();\n        bufferedWriter.close();\n    }\n}",
        "readme": "null\n\nThe Calendar class is an abstract class that provides methods for converting between a specific instant in time and a set of calendar fields such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so on, and for manipulating the calendar fields, such as getting the date of the next week.\n\nYou are given a date. You just need to write the method, , which returns the day on that date. To simplify your task, we have provided a portion of the code in the editor.\n\nExample\n\n\n\n\nThe method should return  as the day on that date.\n\nFunction Description\n\nComplete the findDay function in the editor below.\n\nfindDay has the following parameters:\n\nint: month\nint: day\nint: year\n\nReturns\n\nstring: the day of the week in capital letters\n\nInput Format\n\nA single line of input containing the space separated month, day and year, respectively, in    format.\n\nConstraints\n\nSample Input\n\n08 05 2015\n\n\nSample Output\n\nWEDNESDAY\n\n\nExplanation\n\nThe day on August th  was WEDNESDAY.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-12-29T08:10:52.000Z"
    },
    {
      "id": "hackerrank-medium-java-int-to-string",
      "platform": "Hackerrank",
      "difficulty": "Medium",
      "problemName": "Java Int to String",
      "language": "java",
      "files": {
        "code": "import java.util.Scanner;\n\nclass Solution\n{\n    public static void main(String args[])\n    {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.close();\n        \n        String s = Integer.toString(n);\n        \n        if(n == Integer.parseInt(s))\n            System.out.println(\"Good job\");\n        else\n            System.out.println(\"Wrong Answer\");\n    }\n}",
        "readme": "",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": false,
      "hasNotes": false,
      "lastUpdated": "2025-12-29T08:09:51.000Z"
    },
    {
      "id": "hackerrank-medium-java-stdin-and-stdout-ii",
      "platform": "Hackerrank",
      "difficulty": "Medium",
      "problemName": "Java Stdin and Stdout II",
      "language": "java",
      "files": {
        "code": "import java.util.Scanner;\n\nclass Solution\n{\n    public static void main(String args[])\n    {\n        Scanner sc = new Scanner(System.in);\n        \n        int n = sc.nextInt();\n        double d = sc.nextDouble();\n        sc.nextLine();\n        String s = sc.nextLine();\n        \n        sc.close();\n        \n        System.out.println(\"String: \" + s);\n        System.out.println(\"Double: \" + d);\n        System.out.println(\"Int: \" + n);\n    }\n}",
        "readme": "null\n\nIn this challenge, you must read an integer, a double, and a String from stdin, then print the values according to the instructions in the Output Format section below. To make the problem a little easier, a portion of the code is provided for you in the editor.\n\nNote: We recommend completing Java Stdin and Stdout I before attempting this challenge.\n\nInput Format\n\nThere are three lines of input:\n\nThe first line contains an integer.\nThe second line contains a double.\nThe third line contains a String.\n\nOutput Format\n\nThere are three lines of output:\n\nOn the first line, print String: followed by the unaltered String read from stdin.\nOn the second line, print Double: followed by the unaltered double read from stdin.\nOn the third line, print Int: followed by the unaltered integer read from stdin.\n\nTo make the problem easier, a portion of the code is already provided in the editor.\n\nNote: If you use the nextLine() method immediately following the nextInt() method, recall that nextInt() reads integer tokens; because of this, the last newline character for that line of integer input is still queued in the input buffer and the next nextLine() will be reading the remainder of the integer line (which is empty).\n\nSample Input\n\n42\n3.1415\nWelcome to HackerRank's Java tutorials!\n\n\nSample Output\n\nString: Welcome to HackerRank's Java tutorials!\nDouble: 3.1415\nInt: 42",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-12-29T08:09:06.000Z"
    },
    {
      "id": "leetcode-easy-longest-common-prefix",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Longest Common Prefix",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public String longestCommonPrefix(String[] v) {\n        StringBuilder ans = new StringBuilder();\n        Arrays.sort(v);\n        String first = v[0];\n        String last = v[v.length-1];\n        for (int i=0; i<Math.min(first.length(), last.length()); i++) {\n            if (first.charAt(i) != last.charAt(i)) {\n                return ans.toString();\n            }\n            ans.append(first.charAt(i));\n        }\n        return ans.toString();\n    }\n}",
        "readme": "ArrayStringTrie\n\nWrite a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string \"\".\n\nÂ \nExample 1:\n\nInput: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"\n\n\nExample 2:\n\nInput: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings.\n\n\nÂ \nConstraints:\n\n\n\t1 <= strs.length <= 200\n\t0 <= strs[i].length <= 200\n\tstrs[i] consists of only lowercase English letters if it is non-empty.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-05T17:27:23.000Z"
    },
    {
      "id": "leetcode-easy-minimum-time-visiting-all-points",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Minimum Time Visiting All Points",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int minTimeToVisitAllPoints(int[][] points) {\n        int ans = 0;\n        for (int i = 0; i < points.length - 1; i++) {\n            int currX = points[i][0];\n            int currY = points[i][1];\n            int targetX = points[i + 1][0];\n            int targetY = points[i + 1][1];\n            ans += Math.max(Math.abs(targetX - currX), Math.abs(targetY - currY));\n        }\n        \n        return ans;\n    }\n}",
        "readme": "",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": false,
      "hasNotes": false,
      "lastUpdated": "2026-01-12T07:43:19.000Z"
    },
    {
      "id": "leetcode-easy-n-repeated-element-in-size-2n-array",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "N-Repeated Element in Size 2N Array",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int repeatedNTimes(int[] nums) {\n        int n = nums.length - 1;\n        if(nums[0] == nums[n]) return nums[0];\n        for(int i = 0; i < n; i++) {\n            if(nums[i] == nums[i + 1] || nums[i] == nums[i + 2]) return nums[i];\n        }\n        return nums[0];\n    }\n}",
        "readme": "",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": false,
      "hasNotes": false,
      "lastUpdated": "2026-01-02T12:14:05.000Z"
    },
    {
      "id": "leetcode-easy-plus-one",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Plus One",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int[] plusOne(int[] digits) {\n        for (int i = digits.length - 1; i >= 0; i--) {\n            if (digits[i] < 9) {\n                digits[i]++;\n                return digits;\n            }\n            digits[i] = 0;\n        }\n        int[] result = new int[digits.length + 1];\n        result[0] = 1;\n        return result;\n    }\n}",
        "readme": "DailyCodingChallengeCompleted!,CompletionStreak:,169,Days,Consistencyiskey,seeyoutomorrow!\n\nYou are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\n\nIncrement the large integer by one and return the resulting array of digits.\n\nÂ \nExample 1:\n\nInput: digits = [1,2,3]\nOutput: [1,2,4]\nExplanation: The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be [1,2,4].\n\n\nExample 2:\n\nInput: digits = [4,3,2,1]\nOutput: [4,3,2,2]\nExplanation: The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be [4,3,2,2].\n\n\nExample 3:\n\nInput: digits = [9]\nOutput: [1,0]\nExplanation: The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be [1,0].\n\n\nÂ \nConstraints:\n\n\n\t1 <= digits.length <= 100\n\t0 <= digits[i] <= 9\n\tdigits does not contain any leading 0's.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-01T09:43:58.000Z"
    },
    {
      "id": "leetcode-medium-four-divisors",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Four Divisors",
      "language": "java",
      "files": {
        "code": "class Solution {\n    private int factors(int n) {\n        int sum = 0, c = 0;\n        for(int i = 2; i*i <= n; i++) {\n            if(n % i == 0) {\n                int j = n / i;\n                if(j == i || c > 0) return 0;\n                sum += i + j;\n                c++;\n            }\n        }\n        if(c == 0) return 0;\n        return 1 + sum + n;\n    }\n    public int sumFourDivisors(int[] nums) {\n        int sum = 0;\n        for(int i = 0; i < nums.length; i++) {\n            sum += factors(nums[i]);\n        }\n        return sum;\n    }\n}",
        "readme": "DailyCodingChallengeCompleted!,CompletionStreak:,172,Days,Consistencyiskey,seeyoutomorrow!\n\nGiven an integer array nums, return the sum of divisors of the integers in that array that have exactly four divisors. If there is no such integer in the array, return 0.\n\nÂ \nExample 1:\n\nInput: nums = [21,4,7]\nOutput: 32\nExplanation: \n21 has 4 divisors: 1, 3, 7, 21\n4 has 3 divisors: 1, 2, 4\n7 has 2 divisors: 1, 7\nThe answer is the sum of divisors of 21 only.\n\n\nExample 2:\n\nInput: nums = [21,21]\nOutput: 64\n\n\nExample 3:\n\nInput: nums = [1,2,3,4,5]\nOutput: 0\n\n\nÂ \nConstraints:\n\n\n\t1 <= nums.length <= 104\n\t1 <= nums[i] <= 105",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-04T13:45:09.000Z"
    },
    {
      "id": "leetcode-medium-integer-to-roman",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Integer to Roman",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public static void main(String[] args) {}\n\n    public String intToRoman(int num) {\n        String[][] s = {\n            {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"},\n            {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"},\n            {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"},\n            {\"\", \"M\", \"MM\", \"MMM\"}\n        };\n\n        return s[3][num / 1000 % 10] + s[2][num / 100 % 10] + s[1][num / 10 % 10] + s[0][num % 10];\n    }\n}",
        "readme": "HashTableMathString\n\nSeven different symbols represent Roman numerals with the following values:\n\nSymbolValueI1V5X10L50C100D500M1000\n\nRoman numerals are formed by appendingÂ the conversions ofÂ decimal place valuesÂ from highest to lowest. Converting a decimal place value into a Roman numeral has the following rules:\n\n\n\tIf the value does not start with 4 orÂ 9, select the symbol of the maximal value that can be subtracted from the input, append that symbol to the result, subtract its value, and convert the remainder to a Roman numeral.\n\tIf the value starts with 4 or 9 use theÂ subtractive formÂ representingÂ one symbol subtracted from the following symbol, for example,Â 4 is 1 (I) less than 5 (V): IVÂ and 9 is 1 (I) less than 10 (X): IX.Â Only the following subtractive forms are used: 4 (IV), 9 (IX),Â 40 (XL), 90 (XC), 400 (CD) and 900 (CM).\n\tOnly powers of 10 (I, X, C, M) can be appended consecutively at most 3 times to represent multiples of 10. You cannot append 5Â (V), 50 (L), or 500 (D) multiple times. If you need to append a symbolÂ 4 timesÂ use the subtractive form.\n\n\nGiven an integer, convert it to a Roman numeral.\n\nÂ \nExample 1:\n\n\nInput: num = 3749\n\nOutput: \"MMMDCCXLIX\"\n\nExplanation:\n\n3000 = MMM as 1000 (M) + 1000 (M) + 1000 (M)\n 700 = DCC as 500 (D) + 100 (C) + 100 (C)\n  40 = XL as 10 (X) less of 50 (L)\n   9 = IX as 1 (I) less of 10 (X)\nNote: 49 is not 1 (I) less of 50 (L) because the conversion is based on decimal places\n\n\n\nExample 2:\n\n\nInput: num = 58\n\nOutput: \"LVIII\"\n\nExplanation:\n\n50 = L\n 8 = VIII\n\n\n\nExample 3:\n\n\nInput: num = 1994\n\nOutput: \"MCMXCIV\"\n\nExplanation:\n\n1000 = M\n 900 = CM\n  90 = XC\n   4 = IV\n\n\n\nÂ \nConstraints:\n\n\n\t1 <= num <= 3999",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-12-29T07:54:23.000Z"
    },
    {
      "id": "leetcode-medium-magic-squares-in-grid",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Magic Squares In Grid",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public boolean isMagicSquare(int[][] grid, int r, int c) {\n        if (grid[r+1][c+1] != 5) return false; //center must always be 5\n\n        int a = grid[r][c],b = grid[r][c+1],d = grid[r][c+2]; // grid ele except centre\n        int e = grid[r+1][c],f = grid[r+1][c+2];\n        int h = grid[r+2][c],i = grid[r+2][c+1],j = grid[r+2][c+2];\n\n        boolean[] seen = new boolean[10];\n        int[] arr = {a,b,d,e,f,h,i,j,5};// 1 - 9 checking\n        for (int x : arr) {\n            if (x < 1 || x > 9 || seen[x]) return false;\n            seen[x] = true;\n        }\n\n        if (a + j != 10) return false; //opposite cells must sum to 10\n        if (b + i != 10) return false;\n        if (d + h != 10) return false;\n        if (e + f != 10) return false;\n\n         // Check all rows, columns, and diagonals sum to 15\n        if (a + b + d != 15) return false;\n        if (h + i + j != 15) return false;\n        if (a + e + h != 15) return false;\n        if (d + f + j != 15) return false;\n        if (a + 5 + j != 15) return false;// centre is 5\n        if (d + 5 + h != 15) return false;\n\n        return true;\n    }\n\n    public int numMagicSquaresInside(int[][] grid) {\n        int m = grid.length, n = grid[0].length, c = 0;\n        for (int i = 0;i <= m-3;i++) {\n            for (int j = 0;j <= n-3;j++) {\n                if (isMagicSquare(grid,i,j)) c++;\n            }\n        }\n        return c;\n    }\n}",
        "readme": "DailyCodingChallengeCompleted!,CompletionStreak:,167,Days,Consistencyiskey,seeyoutomorrow!\n\nA 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum.\n\nGiven a row x col grid of integers, how many 3 x 3 magic square subgrids are there?\n\nNote: while a magic square can only contain numbers from 1 to 9, grid may contain numbers up to 15.\n\nÂ \nExample 1:\n\nInput: grid = [[4,3,8,4],[9,5,1,9],[2,7,6,2]]\nOutput: 1\nExplanation: \nThe following subgrid is a 3 x 3 magic square:\n\nwhile this one is not:\n\nIn total, there is only one magic square inside the given grid.\n\n\nExample 2:\n\nInput: grid = [[8]]\nOutput: 0\n\n\nÂ \nConstraints:\n\n\n\trow == grid.length\n\tcol == grid[i].length\n\t1 <= row, col <= 10\n\t0 <= grid[i][j] <= 15",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-12-30T15:11:28.000Z"
    },
    {
      "id": "leetcode-medium-maximum-matrix-sum",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Maximum Matrix Sum",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public long maxMatrixSum(int[][] matrix) {\n        long sum = 0 ;\n\n        int n = matrix.length ;\n\n        int min = 100001 ;\n\n        int negCount = 0 ;\n\n        for (int[] row : matrix)\n        {\n            for (int val : row)\n            {\n                if (val < 0)\n                {\n                    negCount++ ;\n                    val = -val ;\n                }\n\n                if (val < min) min = val ;\n\n                sum += val ;\n            }\n        }\n\n        return negCount % 2 == 0 ? sum : sum - 2L * min ;\n    }\n}",
        "readme": "DailyCodingChallengeCompleted!,CompletionStreak:,173,Days,Consistencyiskey,seeyoutomorrow!\n\nYou are given an n x n integer matrix. You can do the following operation any number of times:\n\n\n\tChoose any two adjacent elements of matrix and multiply each of them by -1.\n\n\nTwo elements are considered adjacent if and only if they share a border.\n\nYour goal is to maximize the summation of the matrix's elements. Return the maximum sum of the matrix's elements using the operation mentioned above.\n\nÂ \nExample 1:\n\nInput: matrix = [[1,-1],[-1,1]]\nOutput: 4\nExplanation: We can follow the following steps to reach sum equals 4:\n- Multiply the 2 elements in the first row by -1.\n- Multiply the 2 elements in the first column by -1.\n\n\nExample 2:\n\nInput: matrix = [[1,2,3],[-1,-2,-3],[1,2,3]]\nOutput: 16\nExplanation: We can follow the following step to reach sum equals 16:\n- Multiply the 2 last elements in the second row by -1.\n\n\nÂ \nConstraints:\n\n\n\tn == matrix.length == matrix[i].length\n\t2 <= n <= 250\n\t-105 <= matrix[i][j] <= 105",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-05T11:39:42.000Z"
    },
    {
      "id": "leetcode-medium-maximum-product-of-splitted-binary-tree",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Maximum Product of Splitted Binary Tree",
      "language": "java",
      "files": {
        "code": "class Solution {\n    static final int MOD = 1_000_000_007;\n    long totalSum = 0;\n    long maxProduct = 0;\n\n    // First DFS: compute total tree sum\n    long getTotalSum(TreeNode root) {\n        if (root == null) return 0;\n        return root.val \n             + getTotalSum(root.left) \n             + getTotalSum(root.right);\n    }\n\n    // Second DFS (postorder): compute subtree sums\n    long dfs(TreeNode root) {\n        if (root == null) return 0;\n\n        // Get sums of left and right subtrees\n        long left = dfs(root.left);\n        long right = dfs(root.right);\n\n        // Current subtree sum\n        long subSum = root.val + left + right;\n\n        // Try splitting above this node\n        long product = subSum * (totalSum - subSum);\n        maxProduct = Math.max(maxProduct, product);\n\n        return subSum;\n    }\n\n    public int maxProduct(TreeNode root) {\n        totalSum = getTotalSum(root); // O(n)\n        dfs(root);                    // O(n)\n        return (int)(maxProduct % MOD);\n    }\n}",
        "readme": "ðŸ—“ï¸Make-upnotice,ThisistheDailyCodingChallengeforJanuary7th2026.Thereare2incompletechallengesforJanuary2026andyouhave1ticketleftforthismonth.Areyousureyouwanttouseatickettomakeupthissubmission?,No,Yes\n\nGiven the root of a binary tree, split the binary tree into two subtrees by removing one edge such that the product of the sums of the subtrees is maximized.\n\nReturn the maximum product of the sums of the two subtrees. Since the answer may be too large, return it modulo 109 + 7.\n\nNote that you need to maximize the answer before taking the mod and not after taking it.\n\nÂ \nExample 1:\n\nInput: root = [1,2,3,4,5,6]\nOutput: 110\nExplanation: Remove the red edge and get 2 binary trees with sum 11 and 10. Their product is 110 (11*10)\n\n\nExample 2:\n\nInput: root = [1,null,2,3,4,null,null,5,6]\nOutput: 90\nExplanation: Remove the red edge and get 2 binary trees with sum 15 and 6.Their product is 90 (15*6)\n\n\nÂ \nConstraints:\n\n\n\tThe number of nodes in the tree is in the range [2, 5 * 104].\n\t1 <= Node.val <= 104",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-08T05:37:48.000Z"
    },
    {
      "id": "leetcode-medium-separate-squares-i",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Separate Squares I",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public double separateSquares(int[][] squares) {\n        List<double[]> events = new ArrayList<>(); \n\n        for (int[] sq : squares) {\n            int yi = sq[1], li = sq[2];\n\n            events.add(new double[]{yi, li});\n            events.add(new double[]{yi + li, -li});\n        }\n\n        events.sort((a, b) -> Double.compare(a[0], b[0]));\n\n        double total_w = 0.0;\n        for (int[] sq : squares) {\n            int li = sq[2];\n            total_w += (double)li * li;\n        }\n\n        double target = total_w / 2.0;\n\n        double curr_y = events.get(0)[0], curr_w = 0.0, accumulated = 0.0;\n\n        for (int i = 0; i < events.size(); i++) {\n            double[] event = events.get(i);\n            double y = event[0], change = event[1];\n\n            double separate = y - curr_y;\n            accumulated += curr_w * separate;\n            \n            if (accumulated >= target) {\n                double prev = accumulated - curr_w * separate;\n\n                double need = target - prev;\n                return curr_y + need / curr_w;\n            }\n\n            curr_y = y;\n            curr_w += change;\n        }\n\n        return 0.0;\n    }\n}",
        "readme": "",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": false,
      "hasNotes": false,
      "lastUpdated": "2026-01-13T15:45:50.000Z"
    },
    {
      "id": "leetcode-hard-last-day-where-you-can-still-cross",
      "platform": "Leetcode",
      "difficulty": "Hard",
      "problemName": "Last Day Where You Can Still Cross",
      "language": "java",
      "files": {
        "code": "class Solution {\n    private int[][] directions = {{1,0},{-1,0},{0,1},{0,-1}};\n    private int rows, cols;\n    public int latestDayToCross(int row, int col, int[][] cells) {\n        this.rows = row;\n        this.cols = col;\n        int left = 1, right = cells.length, answer = 0;\n        while (left<=right){\n            int mid=left+(right-left)/2;\n            if(canCross(mid,cells)){\n                answer=mid;\n                left=mid+1;\n            } else{\n                right=mid-1;\n            }\n        }\n        return answer;\n    }\n    \n    private boolean canCross(int day, int[][] cells) {\n        int[][] grid = new int[rows][cols];\n        \n        for (int i = 0; i < day; i++) {\n            grid[cells[i][0] - 1][cells[i][1] - 1] = 1;\n        }\n        \n        Queue<int[]> queue = new LinkedList<>();\n        boolean[][] visited = new boolean[rows][cols];\n        \n        for (int c = 0; c < cols; c++) {\n            if (grid[0][c] == 0) {\n                queue.offer(new int[]{0, c});\n                visited[0][c] = true;\n            }\n        }\n        \n        while (!queue.isEmpty()) {\n            int[] curr = queue.poll();\n            int r = curr[0], c = curr[1];\n            \n            if (r == rows - 1) return true;\n            \n            for (int[] dir : directions) {\n                int nr = r + dir[0];\n                int nc = c + dir[1];\n                \n                if (nr>=0&&nr<rows&&nc>=0&&nc<cols&&!visited[nr][nc]&&grid[nr][nc]==0){\n                    visited[nr][nc]=true;\n                    queue.offer(new int[]{nr,nc});\n                }\n            }\n        }\n        return false;\n    }\n}",
        "readme": "DailyCodingChallengeCompleted!,YouhavebeenawardedDCCDecember2025!,Consistencyiskey,seeyounextmonth!\n\nThere is a 1-based binary matrix where 0 represents land and 1 represents water. You are given integers row and col representing the number of rows and columns in the matrix, respectively.\n\nInitially on day 0, the entire matrix is land. However, each day a new cell becomes flooded with water. You are given a 1-based 2D array cells, where cells[i] = [ri, ci] represents that on the ith day, the cell on the rith row and cith column (1-based coordinates) will be covered with water (i.e., changed to 1).\n\nYou want to find the last day that it is possible to walk from the top to the bottom by only walking on land cells. You can start from any cell in the top row and end at any cell in the bottom row. You can only travel in the four cardinal directions (left, right, up, and down).\n\nReturn the last day where it is possible to walk from the top to the bottom by only walking on land cells.\n\nÂ \nExample 1:\n\nInput: row = 2, col = 2, cells = [[1,1],[2,1],[1,2],[2,2]]\nOutput: 2\nExplanation: The above image depicts how the matrix changes each day starting from day 0.\nThe last day where it is possible to cross from top to bottom is on day 2.\n\n\nExample 2:\n\nInput: row = 2, col = 2, cells = [[1,1],[1,2],[2,1],[2,2]]\nOutput: 1\nExplanation: The above image depicts how the matrix changes each day starting from day 0.\nThe last day where it is possible to cross from top to bottom is on day 1.\n\n\nExample 3:\n\nInput: row = 3, col = 3, cells = [[1,2],[2,1],[3,3],[2,2],[1,1],[1,3],[2,3],[3,2],[3,1]]\nOutput: 3\nExplanation: The above image depicts how the matrix changes each day starting from day 0.\nThe last day where it is possible to cross from top to bottom is on day 3.\n\n\nÂ \nConstraints:\n\n\n\t2 <= row, col <= 2 * 104\n\t4 <= row * col <= 2 * 104\n\tcells.length == row * col\n\t1 <= ri <= row\n\t1 <= ci <= col\n\tAll the values of cells are unique.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-12-31T14:04:33.000Z"
    },
    {
      "id": "leetcode-hard-max-dot-product-of-two-subsequences",
      "platform": "Leetcode",
      "difficulty": "Hard",
      "problemName": "Max Dot Product of Two Subsequences",
      "language": "java",
      "files": {
        "code": "class Solution {\n\n    // dp[i][j] stores the maximum dot product for nums1[0..i] and nums2[0..j]\n    Integer[][] dp;\n\n    public int maxDotProduct(int[] nums1, int[] nums2) {\n        dp = new Integer[nums1.length][nums2.length];\n        return solve(nums1, nums2, nums1.length - 1, nums2.length - 1);\n    }\n\n    private int solve(int[] nums1, int[] nums2, int i, int j) {\n\n        // Base case: if either array is exhausted\n        if (i < 0 || j < 0) {\n            return Integer.MIN_VALUE; // invalid (non-empty constraint)\n        }\n\n        // If already computed, reuse it\n        if (dp[i][j] != null) {\n            return dp[i][j];\n        }\n\n        // Option 1: take current pair\n        int product = nums1[i] * nums2[j];\n\n        // Option 2: extend a previous subsequence\n        int extend = solve(nums1, nums2, i - 1, j - 1);\n        int take = product;\n        if (extend != Integer.MIN_VALUE) {\n            take = Math.max(take, product + extend);\n        }\n\n        // Option 3: skip one element\n        int skip = Math.max(\n            solve(nums1, nums2, i - 1, j),\n            solve(nums1, nums2, i, j - 1)\n        );\n\n        // Store and return the best result\n        return dp[i][j] = Math.max(take, skip);\n    }\n}",
        "readme": "DailyCodingChallengeCompleted!,CompletionStreak:,176,Days,Consistencyiskey,seeyoutomorrow!\n\nGiven two arrays nums1Â and nums2.\n\nReturn the maximum dot productÂ betweenÂ non-empty subsequences of nums1 and nums2 with the same length.\n\nA subsequence of a array is a new array which is formed from the original array by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie,Â [2,3,5]Â is a subsequence ofÂ [1,2,3,4,5]Â while [1,5,3]Â is not).\n\nÂ \nExample 1:\n\nInput: nums1 = [2,1,-2,5], nums2 = [3,0,-6]\nOutput: 18\nExplanation: Take subsequence [2,-2] from nums1 and subsequence [3,-6] from nums2.\nTheir dot product is (2*3 + (-2)*(-6)) = 18.\n\nExample 2:\n\nInput: nums1 = [3,-2], nums2 = [2,-6,7]\nOutput: 21\nExplanation: Take subsequence [3] from nums1 and subsequence [7] from nums2.\nTheir dot product is (3*7) = 21.\n\nExample 3:\n\nInput: nums1 = [-1,-1], nums2 = [1,1]\nOutput: -1\nExplanation: Take subsequence [-1] from nums1 and subsequence [1] from nums2.\nTheir dot product is -1.\n\nÂ \nConstraints:\n\n\n\t1 <= nums1.length, nums2.length <= 500\n\t-1000 <= nums1[i], nums2[i] <= 1000",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-08T05:38:27.000Z"
    },
    {
      "id": "leetcode-hard-maximal-rectangle",
      "platform": "Leetcode",
      "difficulty": "Hard",
      "problemName": "Maximal Rectangle",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int maximalRectangle(char[][] matrix) {\n        int m = matrix.length, n = matrix[0].length, ans = 0;\n        int[]hist = new int[n];\n\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(matrix[i][j]!='0')hist[j]+=1;\n                else hist[j] = 0;\n            }\n            int area = area(hist);\n            ans = Math.max(ans, area);\n        }\n\n        return ans;\n       \n    }\n\n    public static int area(int[] heights) {\n        int n = heights.length;\n        int maxArea = 0;\n        Stack<Integer> stack = new Stack<>();\n\n        for (int i = 0; i <= n; i++) {\n            int h = (i == n) ? 0 : heights[i];\n            while (!stack.isEmpty() && h < heights[stack.peek()]) {\n                int height = heights[stack.pop()];\n                int width = stack.isEmpty() ? i : i - stack.peek() - 1;\n                maxArea = Math.max(maxArea, height * width);\n            }\n            stack.push(i);\n        }\n\n        return maxArea;\n    }\n}",
        "readme": "DailyCodingChallengeCompleted!,CompletionStreak:,179,Days,Consistencyiskey,seeyoutomorrow!\n\nGiven a rows x colsÂ binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.\n\nÂ \nExample 1:\n\nInput: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\nOutput: 6\nExplanation: The maximal rectangle is shown in the above picture.\n\n\nExample 2:\n\nInput: matrix = [[\"0\"]]\nOutput: 0\n\n\nExample 3:\n\nInput: matrix = [[\"1\"]]\nOutput: 1\n\n\nÂ \nConstraints:\n\n\n\trows == matrix.length\n\tcols == matrix[i].length\n\t1 <= rows, cols <= 200\n\tmatrix[i][j] is '0' or '1'.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-11T14:18:18.000Z"
    }
  ]
}