{
  "metadata": {
    "totalProblems": 7,
    "lastUpdated": "2025-12-31T14:04:45.023Z",
    "breakdown": {
      "Codechef": {
        "total": 0,
        "Easy": 0,
        "Medium": 0,
        "Hard": 0
      },
      "Gfg": {
        "total": 1,
        "Easy": 1,
        "Medium": 0,
        "Hard": 0
      },
      "Leetcode": {
        "total": 3,
        "Easy": 0,
        "Medium": 2,
        "Hard": 1
      },
      "Hackerrank": {
        "total": 3,
        "Easy": 0,
        "Medium": 3,
        "Hard": 0
      }
    }
  },
  "problems": [
    {
      "id": "gfg-easy-decision-making-in-java",
      "platform": "Gfg",
      "difficulty": "Easy",
      "problemName": "Decision Making in Java",
      "language": "java",
      "files": {
        "code": "class Solution {\n     static String compareNM(int n, int m){\n        if(n<m){\n            return \"lesser\";\n        }\n        else if(n==m){\n            return \"equal\";\n        }\n        else{\n            return \"greater\";\n        }\n        \n    }\n }",
        "readme": "Decision_Making_Javaif_Else_Switch_Break_Continue_Jump\n\nDecision Making in Java\nDifficulty: BasicAccuracy: 60.12%Submissions: 208K+Points: 1\n\nGiven two integers, n and m. The task is to check the relation between n and m. Return \"lesser\" if n < m,  \"equal\" if n == m, and \"greater\" if n > m.\n\nExamples :\n\n\nInput: n = 4, m = 8\nOutput: lesser\nExplanation: 4 < 8 so print 'lesser'.\nInput: n = 8, m = 8\nOutput: equal\nExplanation: 8 = 8 so print 'equal'.\nInput: n = 8, m = 4\nOutput: greater\nExplanation: 8 > 4 so print 'greater'.\n\nConstraints:\n-109 <= m , n <= 109\n\n\nTry more examples\nExpected Complexities\nTopic Tags\nRelated Articles\nReport An Issue\nIf you are facing any issue on this page. Please let us know.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-12-29T08:07:30.000Z"
    },
    {
      "id": "hackerrank-medium-java-date-and-time",
      "platform": "Hackerrank",
      "difficulty": "Medium",
      "problemName": "Java Date and Time",
      "language": "java",
      "files": {
        "code": "import java.io.*;\nimport java.math.*;\nimport java.security.*;\nimport java.text.*;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.function.*;\nimport java.util.regex.*;\nimport java.util.stream.*;\nimport static java.util.stream.Collectors.joining;\nimport static java.util.stream.Collectors.toList;\n\nclass Result {\n\n    /*\n     * Complete the 'findDay' function below.\n     *\n     * The function is expected to return a STRING.\n     * The function accepts following parameters:\n     *  1. INTEGER month\n     *  2. INTEGER day\n     *  3. INTEGER year\n     */\n\n    public static String findDay(int month, int day, int year) {\n    Calendar calendar = Calendar.getInstance();\n    calendar.set(year, month - 1, day);\n    var dayOfWeek = calendar.get(calendar.DAY_OF_WEEK);\n    String[] names = new String[] {\"SUNDAY\", \"MONDAY\", \"TUESDAY\", \"WEDNESDAY\", \"THURSDAY\", \"FRIDAY\", \"SATURDAY\"};\n    return names[dayOfWeek - 1];\n}\n\n}\n\npublic class Solution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(\"OUTPUT_PATH\")));\n\n        String[] firstMultipleInput = bufferedReader.readLine().replaceAll(\"\\\\s+$\", \"\").split(\" \");\n\n        int month = Integer.parseInt(firstMultipleInput[0]);\n\n        int day = Integer.parseInt(firstMultipleInput[1]);\n\n        int year = Integer.parseInt(firstMultipleInput[2]);\n\n        String res = Result.findDay(month, day, year);\n\n        bufferedWriter.write(res);\n        bufferedWriter.newLine();\n\n        bufferedReader.close();\n        bufferedWriter.close();\n    }\n}",
        "readme": "null\n\nThe Calendar class is an abstract class that provides methods for converting between a specific instant in time and a set of calendar fields such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so on, and for manipulating the calendar fields, such as getting the date of the next week.\n\nYou are given a date. You just need to write the method, , which returns the day on that date. To simplify your task, we have provided a portion of the code in the editor.\n\nExample\n\n\n\n\nThe method should return  as the day on that date.\n\nFunction Description\n\nComplete the findDay function in the editor below.\n\nfindDay has the following parameters:\n\nint: month\nint: day\nint: year\n\nReturns\n\nstring: the day of the week in capital letters\n\nInput Format\n\nA single line of input containing the space separated month, day and year, respectively, in    format.\n\nConstraints\n\nSample Input\n\n08 05 2015\n\n\nSample Output\n\nWEDNESDAY\n\n\nExplanation\n\nThe day on August th  was WEDNESDAY.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-12-29T08:10:52.000Z"
    },
    {
      "id": "hackerrank-medium-java-int-to-string",
      "platform": "Hackerrank",
      "difficulty": "Medium",
      "problemName": "Java Int to String",
      "language": "java",
      "files": {
        "code": "import java.util.Scanner;\n\nclass Solution\n{\n    public static void main(String args[])\n    {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.close();\n        \n        String s = Integer.toString(n);\n        \n        if(n == Integer.parseInt(s))\n            System.out.println(\"Good job\");\n        else\n            System.out.println(\"Wrong Answer\");\n    }\n}",
        "readme": "",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": false,
      "hasNotes": false,
      "lastUpdated": "2025-12-29T08:09:51.000Z"
    },
    {
      "id": "hackerrank-medium-java-stdin-and-stdout-ii",
      "platform": "Hackerrank",
      "difficulty": "Medium",
      "problemName": "Java Stdin and Stdout II",
      "language": "java",
      "files": {
        "code": "import java.util.Scanner;\n\nclass Solution\n{\n    public static void main(String args[])\n    {\n        Scanner sc = new Scanner(System.in);\n        \n        int n = sc.nextInt();\n        double d = sc.nextDouble();\n        sc.nextLine();\n        String s = sc.nextLine();\n        \n        sc.close();\n        \n        System.out.println(\"String: \" + s);\n        System.out.println(\"Double: \" + d);\n        System.out.println(\"Int: \" + n);\n    }\n}",
        "readme": "null\n\nIn this challenge, you must read an integer, a double, and a String from stdin, then print the values according to the instructions in the Output Format section below. To make the problem a little easier, a portion of the code is provided for you in the editor.\n\nNote: We recommend completing Java Stdin and Stdout I before attempting this challenge.\n\nInput Format\n\nThere are three lines of input:\n\nThe first line contains an integer.\nThe second line contains a double.\nThe third line contains a String.\n\nOutput Format\n\nThere are three lines of output:\n\nOn the first line, print String: followed by the unaltered String read from stdin.\nOn the second line, print Double: followed by the unaltered double read from stdin.\nOn the third line, print Int: followed by the unaltered integer read from stdin.\n\nTo make the problem easier, a portion of the code is already provided in the editor.\n\nNote: If you use the nextLine() method immediately following the nextInt() method, recall that nextInt() reads integer tokens; because of this, the last newline character for that line of integer input is still queued in the input buffer and the next nextLine() will be reading the remainder of the integer line (which is empty).\n\nSample Input\n\n42\n3.1415\nWelcome to HackerRank's Java tutorials!\n\n\nSample Output\n\nString: Welcome to HackerRank's Java tutorials!\nDouble: 3.1415\nInt: 42",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-12-29T08:09:06.000Z"
    },
    {
      "id": "leetcode-medium-integer-to-roman",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Integer to Roman",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public static void main(String[] args) {}\n\n    public String intToRoman(int num) {\n        String[][] s = {\n            {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"},\n            {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"},\n            {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"},\n            {\"\", \"M\", \"MM\", \"MMM\"}\n        };\n\n        return s[3][num / 1000 % 10] + s[2][num / 100 % 10] + s[1][num / 10 % 10] + s[0][num % 10];\n    }\n}",
        "readme": "HashTableMathString\n\nSeven different symbols represent Roman numerals with the following values:\n\nSymbolValueI1V5X10L50C100D500M1000\n\nRoman numerals are formed by appending the conversions of decimal place values from highest to lowest. Converting a decimal place value into a Roman numeral has the following rules:\n\n\n\tIf the value does not start with 4 or 9, select the symbol of the maximal value that can be subtracted from the input, append that symbol to the result, subtract its value, and convert the remainder to a Roman numeral.\n\tIf the value starts with 4 or 9 use the subtractive form representing one symbol subtracted from the following symbol, for example, 4 is 1 (I) less than 5 (V): IV and 9 is 1 (I) less than 10 (X): IX. Only the following subtractive forms are used: 4 (IV), 9 (IX), 40 (XL), 90 (XC), 400 (CD) and 900 (CM).\n\tOnly powers of 10 (I, X, C, M) can be appended consecutively at most 3 times to represent multiples of 10. You cannot append 5 (V), 50 (L), or 500 (D) multiple times. If you need to append a symbol 4 times use the subtractive form.\n\n\nGiven an integer, convert it to a Roman numeral.\n\n \nExample 1:\n\n\nInput: num = 3749\n\nOutput: \"MMMDCCXLIX\"\n\nExplanation:\n\n3000 = MMM as 1000 (M) + 1000 (M) + 1000 (M)\n 700 = DCC as 500 (D) + 100 (C) + 100 (C)\n  40 = XL as 10 (X) less of 50 (L)\n   9 = IX as 1 (I) less of 10 (X)\nNote: 49 is not 1 (I) less of 50 (L) because the conversion is based on decimal places\n\n\n\nExample 2:\n\n\nInput: num = 58\n\nOutput: \"LVIII\"\n\nExplanation:\n\n50 = L\n 8 = VIII\n\n\n\nExample 3:\n\n\nInput: num = 1994\n\nOutput: \"MCMXCIV\"\n\nExplanation:\n\n1000 = M\n 900 = CM\n  90 = XC\n   4 = IV\n\n\n\n \nConstraints:\n\n\n\t1 <= num <= 3999",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-12-29T07:54:23.000Z"
    },
    {
      "id": "leetcode-medium-magic-squares-in-grid",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Magic Squares In Grid",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public boolean isMagicSquare(int[][] grid, int r, int c) {\n        if (grid[r+1][c+1] != 5) return false; //center must always be 5\n\n        int a = grid[r][c],b = grid[r][c+1],d = grid[r][c+2]; // grid ele except centre\n        int e = grid[r+1][c],f = grid[r+1][c+2];\n        int h = grid[r+2][c],i = grid[r+2][c+1],j = grid[r+2][c+2];\n\n        boolean[] seen = new boolean[10];\n        int[] arr = {a,b,d,e,f,h,i,j,5};// 1 - 9 checking\n        for (int x : arr) {\n            if (x < 1 || x > 9 || seen[x]) return false;\n            seen[x] = true;\n        }\n\n        if (a + j != 10) return false; //opposite cells must sum to 10\n        if (b + i != 10) return false;\n        if (d + h != 10) return false;\n        if (e + f != 10) return false;\n\n         // Check all rows, columns, and diagonals sum to 15\n        if (a + b + d != 15) return false;\n        if (h + i + j != 15) return false;\n        if (a + e + h != 15) return false;\n        if (d + f + j != 15) return false;\n        if (a + 5 + j != 15) return false;// centre is 5\n        if (d + 5 + h != 15) return false;\n\n        return true;\n    }\n\n    public int numMagicSquaresInside(int[][] grid) {\n        int m = grid.length, n = grid[0].length, c = 0;\n        for (int i = 0;i <= m-3;i++) {\n            for (int j = 0;j <= n-3;j++) {\n                if (isMagicSquare(grid,i,j)) c++;\n            }\n        }\n        return c;\n    }\n}",
        "readme": "DailyCodingChallengeCompleted!,CompletionStreak:,167,Days,Consistencyiskey,seeyoutomorrow!\n\nA 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum.\n\nGiven a row x col grid of integers, how many 3 x 3 magic square subgrids are there?\n\nNote: while a magic square can only contain numbers from 1 to 9, grid may contain numbers up to 15.\n\n \nExample 1:\n\nInput: grid = [[4,3,8,4],[9,5,1,9],[2,7,6,2]]\nOutput: 1\nExplanation: \nThe following subgrid is a 3 x 3 magic square:\n\nwhile this one is not:\n\nIn total, there is only one magic square inside the given grid.\n\n\nExample 2:\n\nInput: grid = [[8]]\nOutput: 0\n\n\n \nConstraints:\n\n\n\trow == grid.length\n\tcol == grid[i].length\n\t1 <= row, col <= 10\n\t0 <= grid[i][j] <= 15",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-12-30T15:11:28.000Z"
    },
    {
      "id": "leetcode-hard-last-day-where-you-can-still-cross",
      "platform": "Leetcode",
      "difficulty": "Hard",
      "problemName": "Last Day Where You Can Still Cross",
      "language": "java",
      "files": {
        "code": "class Solution {\n    private int[][] directions = {{1,0},{-1,0},{0,1},{0,-1}};\n    private int rows, cols;\n    public int latestDayToCross(int row, int col, int[][] cells) {\n        this.rows = row;\n        this.cols = col;\n        int left = 1, right = cells.length, answer = 0;\n        while (left<=right){\n            int mid=left+(right-left)/2;\n            if(canCross(mid,cells)){\n                answer=mid;\n                left=mid+1;\n            } else{\n                right=mid-1;\n            }\n        }\n        return answer;\n    }\n    \n    private boolean canCross(int day, int[][] cells) {\n        int[][] grid = new int[rows][cols];\n        \n        for (int i = 0; i < day; i++) {\n            grid[cells[i][0] - 1][cells[i][1] - 1] = 1;\n        }\n        \n        Queue<int[]> queue = new LinkedList<>();\n        boolean[][] visited = new boolean[rows][cols];\n        \n        for (int c = 0; c < cols; c++) {\n            if (grid[0][c] == 0) {\n                queue.offer(new int[]{0, c});\n                visited[0][c] = true;\n            }\n        }\n        \n        while (!queue.isEmpty()) {\n            int[] curr = queue.poll();\n            int r = curr[0], c = curr[1];\n            \n            if (r == rows - 1) return true;\n            \n            for (int[] dir : directions) {\n                int nr = r + dir[0];\n                int nc = c + dir[1];\n                \n                if (nr>=0&&nr<rows&&nc>=0&&nc<cols&&!visited[nr][nc]&&grid[nr][nc]==0){\n                    visited[nr][nc]=true;\n                    queue.offer(new int[]{nr,nc});\n                }\n            }\n        }\n        return false;\n    }\n}",
        "readme": "DailyCodingChallengeCompleted!,YouhavebeenawardedDCCDecember2025!,Consistencyiskey,seeyounextmonth!\n\nThere is a 1-based binary matrix where 0 represents land and 1 represents water. You are given integers row and col representing the number of rows and columns in the matrix, respectively.\n\nInitially on day 0, the entire matrix is land. However, each day a new cell becomes flooded with water. You are given a 1-based 2D array cells, where cells[i] = [ri, ci] represents that on the ith day, the cell on the rith row and cith column (1-based coordinates) will be covered with water (i.e., changed to 1).\n\nYou want to find the last day that it is possible to walk from the top to the bottom by only walking on land cells. You can start from any cell in the top row and end at any cell in the bottom row. You can only travel in the four cardinal directions (left, right, up, and down).\n\nReturn the last day where it is possible to walk from the top to the bottom by only walking on land cells.\n\n \nExample 1:\n\nInput: row = 2, col = 2, cells = [[1,1],[2,1],[1,2],[2,2]]\nOutput: 2\nExplanation: The above image depicts how the matrix changes each day starting from day 0.\nThe last day where it is possible to cross from top to bottom is on day 2.\n\n\nExample 2:\n\nInput: row = 2, col = 2, cells = [[1,1],[1,2],[2,1],[2,2]]\nOutput: 1\nExplanation: The above image depicts how the matrix changes each day starting from day 0.\nThe last day where it is possible to cross from top to bottom is on day 1.\n\n\nExample 3:\n\nInput: row = 3, col = 3, cells = [[1,2],[2,1],[3,3],[2,2],[1,1],[1,3],[2,3],[3,2],[3,1]]\nOutput: 3\nExplanation: The above image depicts how the matrix changes each day starting from day 0.\nThe last day where it is possible to cross from top to bottom is on day 3.\n\n\n \nConstraints:\n\n\n\t2 <= row, col <= 2 * 104\n\t4 <= row * col <= 2 * 104\n\tcells.length == row * col\n\t1 <= ri <= row\n\t1 <= ci <= col\n\tAll the values of cells are unique.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-12-31T14:04:33.000Z"
    }
  ]
}