{
  "metadata": {
    "totalProblems": 43,
    "lastUpdated": "2026-02-10T07:43:38.245Z",
    "breakdown": {
      "Codechef": {
        "total": 0,
        "Easy": 0,
        "Medium": 0,
        "Hard": 0
      },
      "Gfg": {
        "total": 1,
        "Easy": 1,
        "Medium": 0,
        "Hard": 0
      },
      "Leetcode": {
        "total": 39,
        "Easy": 12,
        "Medium": 18,
        "Hard": 9
      },
      "Hackerrank": {
        "total": 3,
        "Easy": 0,
        "Medium": 3,
        "Hard": 0
      }
    }
  },
  "problems": [
    {
      "id": "gfg-easy-decision-making-in-java",
      "platform": "Gfg",
      "difficulty": "Easy",
      "problemName": "Decision Making in Java",
      "language": "java",
      "files": {
        "code": "class Solution {\n     static String compareNM(int n, int m){\n        if(n<m){\n            return \"lesser\";\n        }\n        else if(n==m){\n            return \"equal\";\n        }\n        else{\n            return \"greater\";\n        }\n        \n    }\n }",
        "readme": "Decision_Making_Javaif_Else_Switch_Break_Continue_Jump\n\nDecision Making in Java\nDifficulty: BasicAccuracy: 60.12%Submissions: 208K+Points: 1\n\nGiven two integers, n and m. The task is to check the relation between n and m. Return \"lesser\" if n < m,  \"equal\" if n == m, and \"greater\" if n > m.\n\nExamples :\n\n\nInput: n = 4, m = 8\nOutput: lesser\nExplanation: 4 < 8 so print 'lesser'.\nInput: n = 8, m = 8\nOutput: equal\nExplanation: 8 = 8 so print 'equal'.\nInput: n = 8, m = 4\nOutput: greater\nExplanation: 8 > 4 so print 'greater'.\n\nConstraints:\n-109 <= m , n <= 109\n\n\nTry more examples\nExpected Complexities\nTopic Tags\nRelated Articles\nReport An Issue\nIf you are facing any issue on this page. Please let us know.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-12-29T08:07:30.000Z"
    },
    {
      "id": "hackerrank-medium-java-date-and-time",
      "platform": "Hackerrank",
      "difficulty": "Medium",
      "problemName": "Java Date and Time",
      "language": "java",
      "files": {
        "code": "import java.io.*;\nimport java.math.*;\nimport java.security.*;\nimport java.text.*;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.function.*;\nimport java.util.regex.*;\nimport java.util.stream.*;\nimport static java.util.stream.Collectors.joining;\nimport static java.util.stream.Collectors.toList;\n\nclass Result {\n\n    /*\n     * Complete the 'findDay' function below.\n     *\n     * The function is expected to return a STRING.\n     * The function accepts following parameters:\n     *  1. INTEGER month\n     *  2. INTEGER day\n     *  3. INTEGER year\n     */\n\n    public static String findDay(int month, int day, int year) {\n    Calendar calendar = Calendar.getInstance();\n    calendar.set(year, month - 1, day);\n    var dayOfWeek = calendar.get(calendar.DAY_OF_WEEK);\n    String[] names = new String[] {\"SUNDAY\", \"MONDAY\", \"TUESDAY\", \"WEDNESDAY\", \"THURSDAY\", \"FRIDAY\", \"SATURDAY\"};\n    return names[dayOfWeek - 1];\n}\n\n}\n\npublic class Solution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(\"OUTPUT_PATH\")));\n\n        String[] firstMultipleInput = bufferedReader.readLine().replaceAll(\"\\\\s+$\", \"\").split(\" \");\n\n        int month = Integer.parseInt(firstMultipleInput[0]);\n\n        int day = Integer.parseInt(firstMultipleInput[1]);\n\n        int year = Integer.parseInt(firstMultipleInput[2]);\n\n        String res = Result.findDay(month, day, year);\n\n        bufferedWriter.write(res);\n        bufferedWriter.newLine();\n\n        bufferedReader.close();\n        bufferedWriter.close();\n    }\n}",
        "readme": "null\n\nThe Calendar class is an abstract class that provides methods for converting between a specific instant in time and a set of calendar fields such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so on, and for manipulating the calendar fields, such as getting the date of the next week.\n\nYou are given a date. You just need to write the method, , which returns the day on that date. To simplify your task, we have provided a portion of the code in the editor.\n\nExample\n\n\n\n\nThe method should return  as the day on that date.\n\nFunction Description\n\nComplete the findDay function in the editor below.\n\nfindDay has the following parameters:\n\nint: month\nint: day\nint: year\n\nReturns\n\nstring: the day of the week in capital letters\n\nInput Format\n\nA single line of input containing the space separated month, day and year, respectively, in    format.\n\nConstraints\n\nSample Input\n\n08 05 2015\n\n\nSample Output\n\nWEDNESDAY\n\n\nExplanation\n\nThe day on August th  was WEDNESDAY.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-12-29T08:10:52.000Z"
    },
    {
      "id": "hackerrank-medium-java-int-to-string",
      "platform": "Hackerrank",
      "difficulty": "Medium",
      "problemName": "Java Int to String",
      "language": "java",
      "files": {
        "code": "import java.util.Scanner;\n\nclass Solution\n{\n    public static void main(String args[])\n    {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.close();\n        \n        String s = Integer.toString(n);\n        \n        if(n == Integer.parseInt(s))\n            System.out.println(\"Good job\");\n        else\n            System.out.println(\"Wrong Answer\");\n    }\n}",
        "readme": "",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": false,
      "hasNotes": false,
      "lastUpdated": "2025-12-29T08:09:51.000Z"
    },
    {
      "id": "hackerrank-medium-java-stdin-and-stdout-ii",
      "platform": "Hackerrank",
      "difficulty": "Medium",
      "problemName": "Java Stdin and Stdout II",
      "language": "java",
      "files": {
        "code": "import java.util.Scanner;\n\nclass Solution\n{\n    public static void main(String args[])\n    {\n        Scanner sc = new Scanner(System.in);\n        \n        int n = sc.nextInt();\n        double d = sc.nextDouble();\n        sc.nextLine();\n        String s = sc.nextLine();\n        \n        sc.close();\n        \n        System.out.println(\"String: \" + s);\n        System.out.println(\"Double: \" + d);\n        System.out.println(\"Int: \" + n);\n    }\n}",
        "readme": "null\n\nIn this challenge, you must read an integer, a double, and a String from stdin, then print the values according to the instructions in the Output Format section below. To make the problem a little easier, a portion of the code is provided for you in the editor.\n\nNote: We recommend completing Java Stdin and Stdout I before attempting this challenge.\n\nInput Format\n\nThere are three lines of input:\n\nThe first line contains an integer.\nThe second line contains a double.\nThe third line contains a String.\n\nOutput Format\n\nThere are three lines of output:\n\nOn the first line, print String: followed by the unaltered String read from stdin.\nOn the second line, print Double: followed by the unaltered double read from stdin.\nOn the third line, print Int: followed by the unaltered integer read from stdin.\n\nTo make the problem easier, a portion of the code is already provided in the editor.\n\nNote: If you use the nextLine() method immediately following the nextInt() method, recall that nextInt() reads integer tokens; because of this, the last newline character for that line of integer input is still queued in the input buffer and the next nextLine() will be reading the remainder of the integer line (which is empty).\n\nSample Input\n\n42\n3.1415\nWelcome to HackerRank's Java tutorials!\n\n\nSample Output\n\nString: Welcome to HackerRank's Java tutorials!\nDouble: 3.1415\nInt: 42",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-12-29T08:09:06.000Z"
    },
    {
      "id": "leetcode-easy-balanced-binary-tree",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Balanced Binary Tree",
      "language": "java",
      "files": {
        "code": "class Solution {\n    private int dfs(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        int leftHeight = dfs(root.left);\n        if (leftHeight == -1) {\n            return -1;\n        }\n        int rightHeight = dfs(root.right);\n        if (rightHeight == -1) {\n            return -1;\n        }\n        if (Math.abs(leftHeight - rightHeight) > 1) {\n            return -1;\n        }\n        return 1 + Math.max(leftHeight, rightHeight);\n    }\n\n    public boolean isBalanced(TreeNode root) {\n        return dfs(root) != -1;\n    }\n}",
        "readme": "TreeDepth-FirstSearchBinaryTree\n\nGiven a binary tree, determine if it is height-balanced.\n\n \nExample 1:\n\nInput: root = [3,9,20,null,null,15,7]\nOutput: true\n\n\nExample 2:\n\nInput: root = [1,2,2,3,3,null,null,4,4]\nOutput: false\n\n\nExample 3:\n\nInput: root = []\nOutput: true\n\n\n \nConstraints:\n\n\n\tThe number of nodes in the tree is in the range [0, 5000].\n\t-104 <= Node.val <= 104",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-02-08T16:19:38.000Z"
    },
    {
      "id": "leetcode-easy-construct-the-minimum-bitwise-array-i",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Construct the Minimum Bitwise Array I",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int[] minBitwiseArray(List<Integer> nums) {\n        int ans[] = new int[nums.size()];\n        for(int i = 0; i < nums.size(); i++) {\n            int n = nums.get(i);\n            if(n != 2) ans[i] = n - ((n + 1) & (-n - 1)) / 2;\n            else ans[i] = -1;\n        }  \n        return ans;\n    }\n}",
        "readme": "ArrayBitManipulationBiweeklyContest141\n\nYou are given an array nums consisting of n prime integers.\n\nYou need to construct an array ans of length n, such that, for each index i, the bitwise OR of ans[i] and ans[i] + 1 is equal to nums[i], i.e. ans[i] OR (ans[i] + 1) == nums[i].\n\nAdditionally, you must minimize each value of ans[i] in the resulting array.\n\nIf it is not possible to find such a value for ans[i] that satisfies the condition, then set ans[i] = -1.\n\n \nExample 1:\n\n\nInput: nums = [2,3,5,7]\n\nOutput: [-1,1,4,3]\n\nExplanation:\n\n\n\tFor i = 0, as there is no value for ans[0] that satisfies ans[0] OR (ans[0] + 1) = 2, so ans[0] = -1.\n\tFor i = 1, the smallest ans[1] that satisfies ans[1] OR (ans[1] + 1) = 3 is 1, because 1 OR (1 + 1) = 3.\n\tFor i = 2, the smallest ans[2] that satisfies ans[2] OR (ans[2] + 1) = 5 is 4, because 4 OR (4 + 1) = 5.\n\tFor i = 3, the smallest ans[3] that satisfies ans[3] OR (ans[3] + 1) = 7 is 3, because 3 OR (3 + 1) = 7.\n\n\n\nExample 2:\n\n\nInput: nums = [11,13,31]\n\nOutput: [9,12,15]\n\nExplanation:\n\n\n\tFor i = 0, the smallest ans[0] that satisfies ans[0] OR (ans[0] + 1) = 11 is 9, because 9 OR (9 + 1) = 11.\n\tFor i = 1, the smallest ans[1] that satisfies ans[1] OR (ans[1] + 1) = 13 is 12, because 12 OR (12 + 1) = 13.\n\tFor i = 2, the smallest ans[2] that satisfies ans[2] OR (ans[2] + 1) = 31 is 15, because 15 OR (15 + 1) = 31.\n\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 100\n\t2 <= nums[i] <= 1000\n\tnums[i] is a prime number.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-20T03:40:47.000Z"
    },
    {
      "id": "leetcode-easy-divide-an-array-into-subarrays-with-minimum-cost-i",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Divide an Array Into Subarrays With Minimum Cost I",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int minimumCost(int[] A) {\n        int a = 51, b = 51;\n\n        for (int i = 1; i < A.length; i++) {\n            if (A[i] < a) {\n                b = a;\n                a = A[i];\n            } else if (A[i] < b)\n                b = A[i];\n\n            if (a == 1 && b == 1) break;\n        }\n\n        return A[0] + a + b;\n    }\n}",
        "readme": "ArraySortingEnumerationBiweeklyContest122\n\nYou are given an array of integers nums of length n.\n\nThe cost of an array is the value of its first element. For example, the cost of [1,2,3] is 1 while the cost of [3,4,1] is 3.\n\nYou need to divide nums into 3 disjoint contiguous subarrays.\n\nReturn the minimum possible sum of the cost of these subarrays.\n\n \nExample 1:\n\nInput: nums = [1,2,3,12]\nOutput: 6\nExplanation: The best possible way to form 3 subarrays is: [1], [2], and [3,12] at a total cost of 1 + 2 + 3 = 6.\nThe other possible ways to form 3 subarrays are:\n- [1], [2,3], and [12] at a total cost of 1 + 2 + 12 = 15.\n- [1,2], [3], and [12] at a total cost of 1 + 3 + 12 = 16.\n\n\nExample 2:\n\nInput: nums = [5,4,3]\nOutput: 12\nExplanation: The best possible way to form 3 subarrays is: [5], [4], and [3] at a total cost of 5 + 4 + 3 = 12.\nIt can be shown that 12 is the minimum cost achievable.\n\n\nExample 3:\n\nInput: nums = [10,3,1,1]\nOutput: 12\nExplanation: The best possible way to form 3 subarrays is: [10,3], [1], and [1] at a total cost of 10 + 1 + 1 = 12.\nIt can be shown that 12 is the minimum cost achievable.\n\n\n \nConstraints:\n\n\n\t3 <= n <= 50\n\t1 <= nums[i] <= 50",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-02-01T18:58:46.000Z"
    },
    {
      "id": "leetcode-easy-find-smallest-letter-greater-than-target",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Find Smallest Letter Greater Than Target",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public char nextGreatestLetter(char[] letters, char target) {\n        for (int i = 0; i < letters.length; i++) {\n            if (letters[i] > target) {\n                return letters[i];\n            }\n        }\n        return letters[0];\n    }\n}",
        "readme": "ArrayBinarySearchWeeklyContest62\n\nYou are given an array of characters letters that is sorted in non-decreasing order, and a character target. There are at least two different characters in letters.\n\nReturn the smallest character in letters that is lexicographically greater than target. If such a character does not exist, return the first character in letters.\n\n \nExample 1:\n\nInput: letters = [\"c\",\"f\",\"j\"], target = \"a\"\nOutput: \"c\"\nExplanation: The smallest character that is lexicographically greater than 'a' in letters is 'c'.\n\n\nExample 2:\n\nInput: letters = [\"c\",\"f\",\"j\"], target = \"c\"\nOutput: \"f\"\nExplanation: The smallest character that is lexicographically greater than 'c' in letters is 'f'.\n\n\nExample 3:\n\nInput: letters = [\"x\",\"x\",\"y\",\"y\"], target = \"z\"\nOutput: \"x\"\nExplanation: There are no characters in letters that is lexicographically greater than 'z' so we return letters[0].\n\n\n \nConstraints:\n\n\n\t2 <= letters.length <= 104\n\tletters[i] is a lowercase English letter.\n\tletters is sorted in non-decreasing order.\n\tletters contains at least two different characters.\n\ttarget is a lowercase English letter.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-31T18:03:30.000Z"
    },
    {
      "id": "leetcode-easy-longest-common-prefix",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Longest Common Prefix",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public String longestCommonPrefix(String[] v) {\n        StringBuilder ans = new StringBuilder();\n        Arrays.sort(v);\n        String first = v[0];\n        String last = v[v.length-1];\n        for (int i=0; i<Math.min(first.length(), last.length()); i++) {\n            if (first.charAt(i) != last.charAt(i)) {\n                return ans.toString();\n            }\n            ans.append(first.charAt(i));\n        }\n        return ans.toString();\n    }\n}",
        "readme": "ArrayStringTrie\n\nWrite a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string \"\".\n\n \nExample 1:\n\nInput: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"\n\n\nExample 2:\n\nInput: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings.\n\n\n \nConstraints:\n\n\n\t1 <= strs.length <= 200\n\t0 <= strs[i].length <= 200\n\tstrs[i] consists of only lowercase English letters if it is non-empty.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-05T17:27:23.000Z"
    },
    {
      "id": "leetcode-easy-minimum-absolute-difference",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Minimum Absolute Difference",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public List<List<Integer>> minimumAbsDifference(int[] arr) {\n        Arrays.sort(arr);\n        int minDiff = Integer.MAX_VALUE;\n        for(int i = 0; i < arr.length - 1; i ++) {\n            minDiff = Math.min(minDiff, arr[i + 1] - arr[i]);\n        }\n        List<List<Integer>> res = new ArrayList<>();\n        for(int i = 0; i < arr.length - 1; i ++){\n            if (arr[i + 1] - arr[i] == minDiff) {\n                res.add(Arrays.asList(arr[i], arr[i + 1]));\n            }\n        }\n        return res;\n    }\n}",
        "readme": "ArraySortingWeeklyContest155\n\nGiven an array of distinct integers arr, find all pairs of elements with the minimum absolute difference of any two elements.\n\nReturn a list of pairs in ascending order(with respect to pairs), each pair [a, b] follows\n\n\n\ta, b are from arr\n\ta < b\n\tb - a equals to the minimum absolute difference of any two elements in arr\n\n\n \nExample 1:\n\nInput: arr = [4,2,1,3]\nOutput: [[1,2],[2,3],[3,4]]\nExplanation: The minimum absolute difference is 1. List all pairs with difference equal to 1 in ascending order.\n\nExample 2:\n\nInput: arr = [1,3,6,10,15]\nOutput: [[1,3]]\n\n\nExample 3:\n\nInput: arr = [3,8,-10,23,19,-4,-14,27]\nOutput: [[-14,-10],[19,23],[23,27]]\n\n\n \nConstraints:\n\n\n\t2 <= arr.length <= 105\n\t-106 <= arr[i] <= 106",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-26T09:43:27.000Z"
    },
    {
      "id": "leetcode-easy-minimum-difference-between-highest-and-lowest-of-k-scores",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Minimum Difference Between Highest and Lowest of K Scores",
      "language": "java",
      "files": {
        "code": "import java.util.Arrays;\n\nclass Solution {\n    public int minimumDifference(int[] nums, int k) {\n        if (k == 1) return 0;\n        Arrays.sort(nums);\n        int minDiff = Integer.MAX_VALUE;\n        for (int i = 0; i <= nums.length - k; i++) {\n            int currentDiff = nums[i + k - 1] - nums[i];\n            minDiff = Math.min(minDiff, currentDiff);\n        }\n        return minDiff;\n    }\n}",
        "readme": "DailyCodingChallengeCompleted!,CompletionStreak:,193,Days,Consistencyiskey,seeyoutomorrow!\n\nYou are given a 0-indexed integer array nums, where nums[i] represents the score of the ith student. You are also given an integer k.\n\nPick the scores of any k students from the array so that the difference between the highest and the lowest of the k scores is minimized.\n\nReturn the minimum possible difference.\n\n \nExample 1:\n\nInput: nums = [90], k = 1\nOutput: 0\nExplanation: There is one way to pick score(s) of one student:\n- [90]. The difference between the highest and lowest score is 90 - 90 = 0.\nThe minimum possible difference is 0.\n\n\nExample 2:\n\nInput: nums = [9,4,1,7], k = 2\nOutput: 2\nExplanation: There are six ways to pick score(s) of two students:\n- [9,4,1,7]. The difference between the highest and lowest score is 9 - 4 = 5.\n- [9,4,1,7]. The difference between the highest and lowest score is 9 - 1 = 8.\n- [9,4,1,7]. The difference between the highest and lowest score is 9 - 7 = 2.\n- [9,4,1,7]. The difference between the highest and lowest score is 4 - 1 = 3.\n- [9,4,1,7]. The difference between the highest and lowest score is 7 - 4 = 3.\n- [9,4,1,7]. The difference between the highest and lowest score is 7 - 1 = 6.\nThe minimum possible difference is 2.\n\n \nConstraints:\n\n\n\t1 <= k <= nums.length <= 1000\n\t0 <= nums[i] <= 105",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-25T04:17:05.000Z"
    },
    {
      "id": "leetcode-easy-minimum-pair-removal-to-sort-array-i",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Minimum Pair Removal to Sort Array I",
      "language": "java",
      "files": {
        "code": "class Solution {\n    private boolean isSorted(int[] nums, int n) {\n        for(int i = 1; i < n; i++) {\n            if(nums[i] < nums[i - 1]) return false;\n        }\n        return true;\n    }\n    public int minimumPairRemoval(int[] nums) {\n        int ans = 0, n = nums.length;\n        while(!isSorted(nums, n)) {\n            ans += 1;\n            int min_sum = Integer.MAX_VALUE, pos = -1;\n            for(int i = 1; i < n; i++) {\n                int sum = nums[i - 1] + nums[i];\n                if(sum < min_sum) {\n                    min_sum = sum;\n                    pos = i;\n                }\n            }\n            nums[pos - 1] = min_sum;\n            for(int i = pos; i < n - 1; i++) nums[i] = nums[i + 1];\n            n--;\n        }\n        return ans;\n    }\n}",
        "readme": "DailyCodingChallengeCompleted!,CompletionStreak:,190,Days,Consistencyiskey,seeyoutomorrow!\n\nGiven an array nums, you can perform the following operation any number of times:\n\n\n\tSelect the adjacent pair with the minimum sum in nums. If multiple such pairs exist, choose the leftmost one.\n\tReplace the pair with their sum.\n\n\nReturn the minimum number of operations needed to make the array non-decreasing.\n\nAn array is said to be non-decreasing if each element is greater than or equal to its previous element (if it exists).\n\n \nExample 1:\n\n\nInput: nums = [5,2,3,1]\n\nOutput: 2\n\nExplanation:\n\n\n\tThe pair (3,1) has the minimum sum of 4. After replacement, nums = [5,2,4].\n\tThe pair (2,4) has the minimum sum of 6. After replacement, nums = [5,6].\n\n\nThe array nums became non-decreasing in two operations.\n\n\nExample 2:\n\n\nInput: nums = [1,2,2]\n\nOutput: 0\n\nExplanation:\n\nThe array nums is already sorted.\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 50\n\t-1000 <= nums[i] <= 1000",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-22T14:35:27.000Z"
    },
    {
      "id": "leetcode-easy-minimum-time-visiting-all-points",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Minimum Time Visiting All Points",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int minTimeToVisitAllPoints(int[][] points) {\n        int ans = 0;\n        for (int i = 0; i < points.length - 1; i++) {\n            int currX = points[i][0];\n            int currY = points[i][1];\n            int targetX = points[i + 1][0];\n            int targetY = points[i + 1][1];\n            ans += Math.max(Math.abs(targetX - currX), Math.abs(targetY - currY));\n        }\n        \n        return ans;\n    }\n}",
        "readme": "",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": false,
      "hasNotes": false,
      "lastUpdated": "2026-01-12T07:43:19.000Z"
    },
    {
      "id": "leetcode-easy-n-repeated-element-in-size-2n-array",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "N-Repeated Element in Size 2N Array",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int repeatedNTimes(int[] nums) {\n        int n = nums.length - 1;\n        if(nums[0] == nums[n]) return nums[0];\n        for(int i = 0; i < n; i++) {\n            if(nums[i] == nums[i + 1] || nums[i] == nums[i + 2]) return nums[i];\n        }\n        return nums[0];\n    }\n}",
        "readme": "",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": false,
      "hasNotes": false,
      "lastUpdated": "2026-01-02T12:14:05.000Z"
    },
    {
      "id": "leetcode-easy-plus-one",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Plus One",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int[] plusOne(int[] digits) {\n        for (int i = digits.length - 1; i >= 0; i--) {\n            if (digits[i] < 9) {\n                digits[i]++;\n                return digits;\n            }\n            digits[i] = 0;\n        }\n        int[] result = new int[digits.length + 1];\n        result[0] = 1;\n        return result;\n    }\n}",
        "readme": "DailyCodingChallengeCompleted!,CompletionStreak:,169,Days,Consistencyiskey,seeyoutomorrow!\n\nYou are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\n\nIncrement the large integer by one and return the resulting array of digits.\n\n \nExample 1:\n\nInput: digits = [1,2,3]\nOutput: [1,2,4]\nExplanation: The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be [1,2,4].\n\n\nExample 2:\n\nInput: digits = [4,3,2,1]\nOutput: [4,3,2,2]\nExplanation: The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be [4,3,2,2].\n\n\nExample 3:\n\nInput: digits = [9]\nOutput: [1,0]\nExplanation: The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be [1,0].\n\n\n \nConstraints:\n\n\n\t1 <= digits.length <= 100\n\t0 <= digits[i] <= 9\n\tdigits does not contain any leading 0's.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-01T09:43:58.000Z"
    },
    {
      "id": "leetcode-easy-trionic-array-i",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Trionic Array I",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public boolean isTrionic(int[] nums) {\n        int n = nums.length;\n        if (n < 4) return false;\n\n        int state = 0; \n        for (int i = 0; i < n - 1; i++) {\n            if (state == 0) {\n                if (nums[i] < nums[i + 1]) {\n                    // Increasing\n                } else if (i > 0 && nums[i] > nums[i + 1]) {\n                    state = 1; // Reached peak\n                } else {\n                    return false;\n                }\n            } else if (state == 1) {\n                if (nums[i] > nums[i + 1]) {\n                    // Decreasing\n                } else if (nums[i] < nums[i + 1]) {\n                    state = 2; // Reached valley\n                } else {\n                    return false;\n                }\n            } else if (state == 2) {\n                if (nums[i] < nums[i + 1]) {\n                    // Increasing again\n                } else {\n                    return false;\n                }\n            }\n        }\n        return state == 2;\n    }\n}",
        "readme": "DailyCodingChallengeCompleted!,CompletionStreak:,202,Days,Consistencyiskey,seeyoutomorrow!\n\nYou are given an integer array nums of length n.\n\nAn array is trionic if there exist indices 0 < p < q < n − 1 such that:\n\n\n\tnums[0...p] is strictly increasing,\n\tnums[p...q] is strictly decreasing,\n\tnums[q...n − 1] is strictly increasing.\n\n\nReturn true if nums is trionic, otherwise return false.\n\n \nExample 1:\n\n\nInput: nums = [1,3,5,4,2,6]\n\nOutput: true\n\nExplanation:\n\nPick p = 2, q = 4:\n\n\n\tnums[0...2] = [1, 3, 5] is strictly increasing (1 < 3 < 5).\n\tnums[2...4] = [5, 4, 2] is strictly decreasing (5 > 4 > 2).\n\tnums[4...5] = [2, 6] is strictly increasing (2 < 6).\n\n\n\nExample 2:\n\n\nInput: nums = [2,1,3]\n\nOutput: false\n\nExplanation:\n\nThere is no way to pick p and q to form the required three segments.\n\n\n \nConstraints:\n\n\n\t3 <= n <= 100\n\t-1000 <= nums[i] <= 1000",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-02-03T04:10:37.000Z"
    },
    {
      "id": "leetcode-medium-balance-a-binary-search-tree",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Balance a Binary Search Tree",
      "language": "java",
      "files": {
        "code": "class Solution {\n    List<Integer> nums;\n    public TreeNode balanceBST(TreeNode root) {\n        nums = new ArrayList<Integer>();\n        getNumbers(root);\n        TreeNode res = balanceTree(0,nums.size()-1);\n        return res;\n    }\n    private void getNumbers(TreeNode node){\n        if(node==null) return;\n        getNumbers(node.left);\n        nums.add(node.val);\n        getNumbers(node.right);\n    }\n    private TreeNode balanceTree(int l, int r){\n        if(l>r)return null;\n        int middleIdx = l+ ((r-l)/2);\n        TreeNode res = new TreeNode(nums.get(middleIdx));\n        res.left = balanceTree(l,middleIdx-1);\n        res.right = balanceTree(middleIdx+1,r);\n        return res;\n    }              \n}",
        "readme": "SeniorDivideandConquerGreedyTreeDepth-FirstSearchBinarySearchTreeBinaryTreeWeeklyContest180\n\nGiven the root of a binary search tree, return a balanced binary search tree with the same node values. If there is more than one answer, return any of them.\n\nA binary search tree is balanced if the depth of the two subtrees of every node never differs by more than 1.\n\n \nExample 1:\n\nInput: root = [1,null,2,null,3,null,4,null,null]\nOutput: [2,1,3,null,null,null,4]\nExplanation: This is not the only correct answer, [3,1,4,null,2] is also correct.\n\n\nExample 2:\n\nInput: root = [2,1,3]\nOutput: [2,1,3]\n\n\n \nConstraints:\n\n\n\tThe number of nodes in the tree is in the range [1, 104].\n\t1 <= Node.val <= 105",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-02-09T15:40:26.000Z"
    },
    {
      "id": "leetcode-medium-construct-the-minimum-bitwise-array-ii",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Construct the Minimum Bitwise Array II",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int[] minBitwiseArray(List<Integer> nums) {\n        int ans[] = new int[nums.size()];\n        for(int i = 0; i < nums.size(); i++) {\n            int n = nums.get(i);\n            if(n != 2) ans[i] = n - ((n + 1) & (-n - 1)) / 2;\n            else ans[i] = -1;\n        }  \n        return ans;\n    }\n}",
        "readme": "ArrayBitManipulationBiweeklyContest141\n\nYou are given an array nums consisting of n prime integers.\n\nYou need to construct an array ans of length n, such that, for each index i, the bitwise OR of ans[i] and ans[i] + 1 is equal to nums[i], i.e. ans[i] OR (ans[i] + 1) == nums[i].\n\nAdditionally, you must minimize each value of ans[i] in the resulting array.\n\nIf it is not possible to find such a value for ans[i] that satisfies the condition, then set ans[i] = -1.\n\n \nExample 1:\n\n\nInput: nums = [2,3,5,7]\n\nOutput: [-1,1,4,3]\n\nExplanation:\n\n\n\tFor i = 0, as there is no value for ans[0] that satisfies ans[0] OR (ans[0] + 1) = 2, so ans[0] = -1.\n\tFor i = 1, the smallest ans[1] that satisfies ans[1] OR (ans[1] + 1) = 3 is 1, because 1 OR (1 + 1) = 3.\n\tFor i = 2, the smallest ans[2] that satisfies ans[2] OR (ans[2] + 1) = 5 is 4, because 4 OR (4 + 1) = 5.\n\tFor i = 3, the smallest ans[3] that satisfies ans[3] OR (ans[3] + 1) = 7 is 3, because 3 OR (3 + 1) = 7.\n\n\n\nExample 2:\n\n\nInput: nums = [11,13,31]\n\nOutput: [9,12,15]\n\nExplanation:\n\n\n\tFor i = 0, the smallest ans[0] that satisfies ans[0] OR (ans[0] + 1) = 11 is 9, because 9 OR (9 + 1) = 11.\n\tFor i = 1, the smallest ans[1] that satisfies ans[1] OR (ans[1] + 1) = 13 is 12, because 12 OR (12 + 1) = 13.\n\tFor i = 2, the smallest ans[2] that satisfies ans[2] OR (ans[2] + 1) = 31 is 15, because 15 OR (15 + 1) = 31.\n\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 100\n\t2 <= nums[i] <= 109\n\tnums[i] is a prime number.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-21T03:31:48.000Z"
    },
    {
      "id": "leetcode-medium-find-the-largest-area-of-square-inside-two-rectangles",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Find the Largest Area of Square Inside Two Rectangles",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public long largestSquareArea(int[][] bottomLeft, int[][] topRight) {\n        long maxSide = 0;\n        int n = bottomLeft.length;\n\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Find intersection boundaries\n                // Use Math.max for lower bounds (left, bottom)\n                // Use Math.min for upper bounds (right, top)\n                int x1 = Math.max(bottomLeft[i][0], bottomLeft[j][0]);\n                int y1 = Math.max(bottomLeft[i][1], bottomLeft[j][1]);\n                int x2 = Math.min(topRight[i][0], topRight[j][0]);\n                int y2 = Math.min(topRight[i][1], topRight[j][1]);\n\n                // Width and Height of the intersection rectangle\n                long width = x2 - x1;\n                long height = y2 - y1;\n\n                // If valid intersection (width and height > 0)\n                if (width > 0 && height > 0) {\n                    long side = Math.min(width, height);\n                    maxSide = Math.max(maxSide, side);\n                }\n            }\n        }\n\n        return maxSide * maxSide;\n    }\n}",
        "readme": "ArrayMathGeometryWeeklyContest386\n\nThere exist n rectangles in a 2D plane with edges parallel to the x and y axis. You are given two 2D integer arrays bottomLeft and topRight where bottomLeft[i] = [a_i, b_i] and topRight[i] = [c_i, d_i] represent the bottom-left and top-right coordinates of the ith rectangle, respectively.\n\nYou need to find the maximum area of a square that can fit inside the intersecting region of at least two rectangles. Return 0 if such a square does not exist.\n\n \nExample 1:\n\nInput: bottomLeft = [[1,1],[2,2],[3,1]], topRight = [[3,3],[4,4],[6,6]]\n\nOutput: 1\n\nExplanation:\n\nA square with side length 1 can fit inside either the intersecting region of rectangles 0 and 1 or the intersecting region of rectangles 1 and 2. Hence the maximum area is 1. It can be shown that a square with a greater side length can not fit inside any intersecting region of two rectangles.\n\nExample 2:\n\nInput: bottomLeft = [[1,1],[1,3],[1,5]], topRight = [[5,5],[5,7],[5,9]]\n\nOutput: 4\n\nExplanation:\n\nA square with side length 2 can fit inside either the intersecting region of rectangles 0 and 1 or the intersecting region of rectangles 1 and 2. Hence the maximum area is 2 * 2 = 4. It can be shown that a square with a greater side length can not fit inside any intersecting region of two rectangles.\n\nExample 3:\n  \n\nInput: bottomLeft = [[1,1],[2,2],[1,2]], topRight = [[3,3],[4,4],[3,4]]\n\nOutput: 1\n\nExplanation:\n\nA square with side length 1 can fit inside the intersecting region of any two rectangles. Also, no larger square can, so the maximum area is 1. Note that the region can be formed by the intersection of more than 2 rectangles.\n\nExample 4:\n  \n\nInput: bottomLeft = [[1,1],[3,3],[3,1]], topRight = [[2,2],[4,4],[4,2]]\n\nOutput: 0\n\nExplanation:\n\nNo pair of rectangles intersect, hence, the answer is 0.\n\n \nConstraints:\n\n\n\tn == bottomLeft.length == topRight.length\n\t2 <= n <= 103\n\tbottomLeft[i].length == topRight[i].length == 2\n\t1 <= bottomLeft[i][0], bottomLeft[i][1] <= 107\n\t1 <= topRight[i][0], topRight[i][1] <= 107\n\tbottomLeft[i][0] < topRight[i][0]\n\tbottomLeft[i][1] < topRight[i][1]",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-17T11:05:34.000Z"
    },
    {
      "id": "leetcode-medium-four-divisors",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Four Divisors",
      "language": "java",
      "files": {
        "code": "class Solution {\n    private int factors(int n) {\n        int sum = 0, c = 0;\n        for(int i = 2; i*i <= n; i++) {\n            if(n % i == 0) {\n                int j = n / i;\n                if(j == i || c > 0) return 0;\n                sum += i + j;\n                c++;\n            }\n        }\n        if(c == 0) return 0;\n        return 1 + sum + n;\n    }\n    public int sumFourDivisors(int[] nums) {\n        int sum = 0;\n        for(int i = 0; i < nums.length; i++) {\n            sum += factors(nums[i]);\n        }\n        return sum;\n    }\n}",
        "readme": "DailyCodingChallengeCompleted!,CompletionStreak:,172,Days,Consistencyiskey,seeyoutomorrow!\n\nGiven an integer array nums, return the sum of divisors of the integers in that array that have exactly four divisors. If there is no such integer in the array, return 0.\n\n \nExample 1:\n\nInput: nums = [21,4,7]\nOutput: 32\nExplanation: \n21 has 4 divisors: 1, 3, 7, 21\n4 has 3 divisors: 1, 2, 4\n7 has 2 divisors: 1, 7\nThe answer is the sum of divisors of 21 only.\n\n\nExample 2:\n\nInput: nums = [21,21]\nOutput: 64\n\n\nExample 3:\n\nInput: nums = [1,2,3,4,5]\nOutput: 0\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 104\n\t1 <= nums[i] <= 105",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-04T13:45:09.000Z"
    },
    {
      "id": "leetcode-medium-integer-to-roman",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Integer to Roman",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public static void main(String[] args) {}\n\n    public String intToRoman(int num) {\n        String[][] s = {\n            {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"},\n            {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"},\n            {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"},\n            {\"\", \"M\", \"MM\", \"MMM\"}\n        };\n\n        return s[3][num / 1000 % 10] + s[2][num / 100 % 10] + s[1][num / 10 % 10] + s[0][num % 10];\n    }\n}",
        "readme": "HashTableMathString\n\nSeven different symbols represent Roman numerals with the following values:\n\nSymbolValueI1V5X10L50C100D500M1000\n\nRoman numerals are formed by appending the conversions of decimal place values from highest to lowest. Converting a decimal place value into a Roman numeral has the following rules:\n\n\n\tIf the value does not start with 4 or 9, select the symbol of the maximal value that can be subtracted from the input, append that symbol to the result, subtract its value, and convert the remainder to a Roman numeral.\n\tIf the value starts with 4 or 9 use the subtractive form representing one symbol subtracted from the following symbol, for example, 4 is 1 (I) less than 5 (V): IV and 9 is 1 (I) less than 10 (X): IX. Only the following subtractive forms are used: 4 (IV), 9 (IX), 40 (XL), 90 (XC), 400 (CD) and 900 (CM).\n\tOnly powers of 10 (I, X, C, M) can be appended consecutively at most 3 times to represent multiples of 10. You cannot append 5 (V), 50 (L), or 500 (D) multiple times. If you need to append a symbol 4 times use the subtractive form.\n\n\nGiven an integer, convert it to a Roman numeral.\n\n \nExample 1:\n\n\nInput: num = 3749\n\nOutput: \"MMMDCCXLIX\"\n\nExplanation:\n\n3000 = MMM as 1000 (M) + 1000 (M) + 1000 (M)\n 700 = DCC as 500 (D) + 100 (C) + 100 (C)\n  40 = XL as 10 (X) less of 50 (L)\n   9 = IX as 1 (I) less of 10 (X)\nNote: 49 is not 1 (I) less of 50 (L) because the conversion is based on decimal places\n\n\n\nExample 2:\n\n\nInput: num = 58\n\nOutput: \"LVIII\"\n\nExplanation:\n\n50 = L\n 8 = VIII\n\n\n\nExample 3:\n\n\nInput: num = 1994\n\nOutput: \"MCMXCIV\"\n\nExplanation:\n\n1000 = M\n 900 = CM\n  90 = XC\n   4 = IV\n\n\n\n \nConstraints:\n\n\n\t1 <= num <= 3999",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-12-29T07:54:23.000Z"
    },
    {
      "id": "leetcode-medium-largest-magic-square",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Largest Magic Square",
      "language": "java",
      "files": {
        "code": "class Solution {\n\n    public int largestMagicSquare(int[][] mat) {\n        int R = mat.length;\n        int C = mat[0].length;\n\n        // Row prefix sums\n        int[][] rowSum = new int[R][C];\n        for (int r = 0; r < R; r++) {\n            rowSum[r][0] = mat[r][0];\n            for (int c = 1; c < C; c++) {\n                rowSum[r][c] = rowSum[r][c - 1] + mat[r][c];\n            }\n        }\n\n        // Column prefix sums\n        int[][] colSum = new int[R][C];\n        for (int c = 0; c < C; c++) {\n            colSum[0][c] = mat[0][c];\n            for (int r = 1; r < R; r++) {\n                colSum[r][c] = colSum[r - 1][c] + mat[r][c];\n            }\n        }\n\n        int maxSize = 1;\n\n        // Try every cell as top-left\n        for (int r = 0; r < R; r++) {\n            for (int c = 0; c < C; c++) {\n                int maxPossible = Math.min(R - r, C - c);\n\n                // Try bigger squares first\n                for (int size = maxPossible; size > maxSize; size--) {\n                    if (isMagic(r, c, size, mat, rowSum, colSum)) {\n                        maxSize = size;\n                        break;\n                    }\n                }\n            }\n        }\n        return maxSize;\n    }\n\n    private boolean isMagic(\n            int sr, int sc, int size,\n            int[][] mat, int[][] rowSum, int[][] colSum) {\n\n        // Target sum from first row\n        int target = rowSum[sr][sc + size - 1]\n                   - (sc > 0 ? rowSum[sr][sc - 1] : 0);\n\n        // Check rows\n        for (int r = sr; r < sr + size; r++) {\n            int sum = rowSum[r][sc + size - 1]\n                    - (sc > 0 ? rowSum[r][sc - 1] : 0);\n            if (sum != target) return false;\n        }\n\n        // Check columns\n        for (int c = sc; c < sc + size; c++) {\n            int sum = colSum[sr + size - 1][c]\n                    - (sr > 0 ? colSum[sr - 1][c] : 0);\n            if (sum != target) return false;\n        }\n\n        // Main diagonal\n        int d1 = 0;\n        for (int k = 0; k < size; k++)\n            d1 += mat[sr + k][sc + k];\n        if (d1 != target) return false;\n\n        // Anti-diagonal\n        int d2 = 0;\n        for (int k = 0; k < size; k++)\n            d2 += mat[sr + size - 1 - k][sc + k];\n\n        return d2 == target;\n    }\n}",
        "readme": "DailyCodingChallengeCompleted!,CompletionStreak:,186,Days,Consistencyiskey,seeyoutomorrow!\n\nA k x k magic square is a k x k grid filled with integers such that every row sum, every column sum, and both diagonal sums are all equal. The integers in the magic square do not have to be distinct. Every 1 x 1 grid is trivially a magic square.\n\nGiven an m x n integer grid, return the size (i.e., the side length k) of the largest magic square that can be found within this grid.\n\n \nExample 1:\n\nInput: grid = [[7,1,4,5,6],[2,5,1,6,4],[1,5,4,3,2],[1,2,7,3,4]]\nOutput: 3\nExplanation: The largest magic square has a size of 3.\nEvery row sum, column sum, and diagonal sum of this magic square is equal to 12.\n- Row sums: 5+1+6 = 5+4+3 = 2+7+3 = 12\n- Column sums: 5+5+2 = 1+4+7 = 6+3+3 = 12\n- Diagonal sums: 5+4+3 = 6+4+2 = 12\n\n\nExample 2:\n\nInput: grid = [[5,1,3,1],[9,3,3,1],[1,3,3,8]]\nOutput: 2\n\n\n \nConstraints:\n\n\n\tm == grid.length\n\tn == grid[i].length\n\t1 <= m, n <= 50\n\t1 <= grid[i][j] <= 106",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-18T03:41:28.000Z"
    },
    {
      "id": "leetcode-medium-longest-balanced-subarray-i",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Longest Balanced Subarray I",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int longestBalanced(int[] nums) {\n        int max = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            HashSet<Integer> even = new HashSet<>();\n            HashSet<Integer> odd = new HashSet<>();\n\n            for (int j = i; j < nums.length; j++) {\n                if (nums[j] % 2 == 0)\n                    even.add(nums[j]);\n                else\n                    odd.add(nums[j]);\n\n                if (even.size() == odd.size()) {\n                    max = Math.max(max, j - i + 1);\n                }\n            }\n        }\n        return max;\n    }\n}",
        "readme": "",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": false,
      "hasNotes": false,
      "lastUpdated": "2026-02-10T07:43:26.000Z"
    },
    {
      "id": "leetcode-medium-magic-squares-in-grid",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Magic Squares In Grid",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public boolean isMagicSquare(int[][] grid, int r, int c) {\n        if (grid[r+1][c+1] != 5) return false; //center must always be 5\n\n        int a = grid[r][c],b = grid[r][c+1],d = grid[r][c+2]; // grid ele except centre\n        int e = grid[r+1][c],f = grid[r+1][c+2];\n        int h = grid[r+2][c],i = grid[r+2][c+1],j = grid[r+2][c+2];\n\n        boolean[] seen = new boolean[10];\n        int[] arr = {a,b,d,e,f,h,i,j,5};// 1 - 9 checking\n        for (int x : arr) {\n            if (x < 1 || x > 9 || seen[x]) return false;\n            seen[x] = true;\n        }\n\n        if (a + j != 10) return false; //opposite cells must sum to 10\n        if (b + i != 10) return false;\n        if (d + h != 10) return false;\n        if (e + f != 10) return false;\n\n         // Check all rows, columns, and diagonals sum to 15\n        if (a + b + d != 15) return false;\n        if (h + i + j != 15) return false;\n        if (a + e + h != 15) return false;\n        if (d + f + j != 15) return false;\n        if (a + 5 + j != 15) return false;// centre is 5\n        if (d + 5 + h != 15) return false;\n\n        return true;\n    }\n\n    public int numMagicSquaresInside(int[][] grid) {\n        int m = grid.length, n = grid[0].length, c = 0;\n        for (int i = 0;i <= m-3;i++) {\n            for (int j = 0;j <= n-3;j++) {\n                if (isMagicSquare(grid,i,j)) c++;\n            }\n        }\n        return c;\n    }\n}",
        "readme": "DailyCodingChallengeCompleted!,CompletionStreak:,167,Days,Consistencyiskey,seeyoutomorrow!\n\nA 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum.\n\nGiven a row x col grid of integers, how many 3 x 3 magic square subgrids are there?\n\nNote: while a magic square can only contain numbers from 1 to 9, grid may contain numbers up to 15.\n\n \nExample 1:\n\nInput: grid = [[4,3,8,4],[9,5,1,9],[2,7,6,2]]\nOutput: 1\nExplanation: \nThe following subgrid is a 3 x 3 magic square:\n\nwhile this one is not:\n\nIn total, there is only one magic square inside the given grid.\n\n\nExample 2:\n\nInput: grid = [[8]]\nOutput: 0\n\n\n \nConstraints:\n\n\n\trow == grid.length\n\tcol == grid[i].length\n\t1 <= row, col <= 10\n\t0 <= grid[i][j] <= 15",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-12-30T15:11:28.000Z"
    },
    {
      "id": "leetcode-medium-maximize-area-of-square-hole-in-grid",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Maximize Area of Square Hole in Grid",
      "language": "java",
      "files": {
        "code": "class Solution {\n    private int maxLen(int[] Bars) {\n        int count = 2, length = 2;\n        for(int i = 1; i < Bars.length; i++) {\n            if(Bars[i] - Bars[i-1] == 1) count++;\n            else count = 2;\n            length = Math.max(length, count);\n        }\n        return length;\n    }\n    public int maximizeSquareHoleArea(int n, int m, int[] hBars, int[] vBars) {\n        Arrays.sort(hBars);\n        Arrays.sort(vBars);\n        int side = Math.min(maxLen(hBars), maxLen(vBars));\n        return side * side; \n    }\n}",
        "readme": "ArraySortingBiweeklyContest118\n\nYou are given the two integers, n and m and two integer arrays, hBars and vBars. The grid has n + 2 horizontal and m + 2 vertical bars, creating 1 x 1 unit cells. The bars are indexed starting from 1.\n\nYou can remove some of the bars in hBars from horizontal bars and some of the bars in vBars from vertical bars. Note that other bars are fixed and cannot be removed.\n\nReturn an integer denoting the maximum area of a square-shaped hole in the grid, after removing some bars (possibly none).\n\n \nExample 1:\n\n\n\n\nInput: n = 2, m = 1, hBars = [2,3], vBars = [2]\n\nOutput: 4\n\nExplanation:\n\nThe left image shows the initial grid formed by the bars. The horizontal bars are [1,2,3,4], and the vertical bars are [1,2,3].\n\nOne way to get the maximum square-shaped hole is by removing horizontal bar 2 and vertical bar 2.\n\n\nExample 2:\n\n\n\n\nInput: n = 1, m = 1, hBars = [2], vBars = [2]\n\nOutput: 4\n\nExplanation:\n\nTo get the maximum square-shaped hole, we remove horizontal bar 2 and vertical bar 2.\n\n\nExample 3:\n\n\n\n\nInput: n = 2, m = 3, hBars = [2,3], vBars = [2,4]\n\nOutput: 4\n\nExplanation:\n\nOne way to get the maximum square-shaped hole is by removing horizontal bar 3, and vertical bar 4.\n\n\n \nConstraints:\n\n\n\t1 <= n <= 109\n\t1 <= m <= 109\n\t1 <= hBars.length <= 100\n\t2 <= hBars[i] <= n + 1\n\t1 <= vBars.length <= 100\n\t2 <= vBars[i] <= m + 1\n\tAll values in hBars are distinct.\n\tAll values in vBars are distinct.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-15T13:30:58.000Z"
    },
    {
      "id": "leetcode-medium-maximum-matrix-sum",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Maximum Matrix Sum",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public long maxMatrixSum(int[][] matrix) {\n        long sum = 0 ;\n\n        int n = matrix.length ;\n\n        int min = 100001 ;\n\n        int negCount = 0 ;\n\n        for (int[] row : matrix)\n        {\n            for (int val : row)\n            {\n                if (val < 0)\n                {\n                    negCount++ ;\n                    val = -val ;\n                }\n\n                if (val < min) min = val ;\n\n                sum += val ;\n            }\n        }\n\n        return negCount % 2 == 0 ? sum : sum - 2L * min ;\n    }\n}",
        "readme": "DailyCodingChallengeCompleted!,CompletionStreak:,173,Days,Consistencyiskey,seeyoutomorrow!\n\nYou are given an n x n integer matrix. You can do the following operation any number of times:\n\n\n\tChoose any two adjacent elements of matrix and multiply each of them by -1.\n\n\nTwo elements are considered adjacent if and only if they share a border.\n\nYour goal is to maximize the summation of the matrix's elements. Return the maximum sum of the matrix's elements using the operation mentioned above.\n\n \nExample 1:\n\nInput: matrix = [[1,-1],[-1,1]]\nOutput: 4\nExplanation: We can follow the following steps to reach sum equals 4:\n- Multiply the 2 elements in the first row by -1.\n- Multiply the 2 elements in the first column by -1.\n\n\nExample 2:\n\nInput: matrix = [[1,2,3],[-1,-2,-3],[1,2,3]]\nOutput: 16\nExplanation: We can follow the following step to reach sum equals 16:\n- Multiply the 2 last elements in the second row by -1.\n\n\n \nConstraints:\n\n\n\tn == matrix.length == matrix[i].length\n\t2 <= n <= 250\n\t-105 <= matrix[i][j] <= 105",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-05T11:39:42.000Z"
    },
    {
      "id": "leetcode-medium-maximum-product-of-splitted-binary-tree",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Maximum Product of Splitted Binary Tree",
      "language": "java",
      "files": {
        "code": "class Solution {\n    static final int MOD = 1_000_000_007;\n    long totalSum = 0;\n    long maxProduct = 0;\n\n    // First DFS: compute total tree sum\n    long getTotalSum(TreeNode root) {\n        if (root == null) return 0;\n        return root.val \n             + getTotalSum(root.left) \n             + getTotalSum(root.right);\n    }\n\n    // Second DFS (postorder): compute subtree sums\n    long dfs(TreeNode root) {\n        if (root == null) return 0;\n\n        // Get sums of left and right subtrees\n        long left = dfs(root.left);\n        long right = dfs(root.right);\n\n        // Current subtree sum\n        long subSum = root.val + left + right;\n\n        // Try splitting above this node\n        long product = subSum * (totalSum - subSum);\n        maxProduct = Math.max(maxProduct, product);\n\n        return subSum;\n    }\n\n    public int maxProduct(TreeNode root) {\n        totalSum = getTotalSum(root); // O(n)\n        dfs(root);                    // O(n)\n        return (int)(maxProduct % MOD);\n    }\n}",
        "readme": "🗓️Make-upnotice,ThisistheDailyCodingChallengeforJanuary7th2026.Thereare2incompletechallengesforJanuary2026andyouhave1ticketleftforthismonth.Areyousureyouwanttouseatickettomakeupthissubmission?,No,Yes\n\nGiven the root of a binary tree, split the binary tree into two subtrees by removing one edge such that the product of the sums of the subtrees is maximized.\n\nReturn the maximum product of the sums of the two subtrees. Since the answer may be too large, return it modulo 109 + 7.\n\nNote that you need to maximize the answer before taking the mod and not after taking it.\n\n \nExample 1:\n\nInput: root = [1,2,3,4,5,6]\nOutput: 110\nExplanation: Remove the red edge and get 2 binary trees with sum 11 and 10. Their product is 110 (11*10)\n\n\nExample 2:\n\nInput: root = [1,null,2,3,4,null,null,5,6]\nOutput: 90\nExplanation: Remove the red edge and get 2 binary trees with sum 15 and 6.Their product is 90 (15*6)\n\n\n \nConstraints:\n\n\n\tThe number of nodes in the tree is in the range [2, 5 * 104].\n\t1 <= Node.val <= 104",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-08T05:37:48.000Z"
    },
    {
      "id": "leetcode-medium-maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Maximum Side Length of a Square with Sum Less than or Equal to Threshold",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int maxSideLength(int[][] mat, int threshold) {\n        int m = mat.length, n = mat[0].length;\n        int maxSide = Math.min(m,n);\n\n        int[][] pref = new int[m+1][n+1];\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                pref[i][j] =\n                    mat[i-1][j-1]\n                  + pref[i-1][j]\n                  + pref[i][j-1]\n                  - pref[i-1][j-1];\n            }\n        }\n\n        while (maxSide > 0) {\n            for (int i = 0; i + maxSide <= m; i++) {\n                for (int j = 0; j + maxSide <= n; j++) {\n                    if (helper(pref, threshold, i, j, maxSide))\n                        return maxSide;\n                }\n            }\n            maxSide--;\n        }\n\n        return 0;\n    }\n\n    private boolean helper(int[][] pref, int t, int x, int y, int side) {\n        int x2 = x + side;\n        int y2 = y + side;\n\n        int sum =\n            pref[x2][y2]\n        - pref[x][y2]\n        - pref[x2][y]\n        + pref[x][y];\n\n        return sum <= t;\n    }\n\n}",
        "readme": "ArrayBinarySearchMatrixPrefixSumWeeklyContest167\n\nGiven a m x n matrix mat and an integer threshold, return the maximum side-length of a square with a sum less than or equal to threshold or return 0 if there is no such square.\n\n \nExample 1:\n\nInput: mat = [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]], threshold = 4\nOutput: 2\nExplanation: The maximum side length of square with sum less than 4 is 2 as shown.\n\n\nExample 2:\n\nInput: mat = [[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2]], threshold = 1\nOutput: 0\n\n\n \nConstraints:\n\n\n\tm == mat.length\n\tn == mat[i].length\n\t1 <= m, n <= 300\n\t0 <= mat[i][j] <= 104\n\t0 <= threshold <= 105",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-20T03:39:58.000Z"
    },
    {
      "id": "leetcode-medium-maximum-square-area-by-removing-fences-from-a-field",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Maximum Square Area by Removing Fences From a Field",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int maximizeSquareArea(int m, int n, int[] hFences, int[] vFences) {\n        // 1. Add implicit boundary fences to new lists\n        // We use Arrays to facilitate sorting and resizing\n        int[] h = Arrays.copyOf(hFences, hFences.length + 2);\n        h[hFences.length] = 1;\n        h[hFences.length + 1] = m;\n        \n        int[] v = Arrays.copyOf(vFences, vFences.length + 2);\n        v[vFences.length] = 1;\n        v[vFences.length + 1] = n;\n\n        // 2. Sort arrays\n        Arrays.sort(h);\n        Arrays.sort(v);\n\n        // 3. Store all possible horizontal gaps\n        Set<Integer> hGaps = new HashSet<>();\n        for (int i = 0; i < h.length; i++) {\n            for (int j = i + 1; j < h.length; j++) {\n                hGaps.add(h[j] - h[i]);\n            }\n        }\n\n        // 4. Check vertical gaps\n        long maxSide = -1;\n        for (int i = 0; i < v.length; i++) {\n            for (int j = i + 1; j < v.length; j++) {\n                int currentGap = v[j] - v[i];\n                if (hGaps.contains(currentGap)) {\n                    maxSide = Math.max(maxSide, currentGap);\n                }\n            }\n        }\n\n        if (maxSide == -1) return -1;\n\n        // 5. Return result modulo 10^9 + 7\n        long MOD = 1_000_000_007;\n        return (int) ((maxSide * maxSide) % MOD);\n    }\n}",
        "readme": "DailyCodingChallengeCompleted!,CompletionStreak:,184,Days,Consistencyiskey,seeyoutomorrow!\n\nThere is a large (m - 1) x (n - 1) rectangular field with corners at (1, 1) and (m, n) containing some horizontal and vertical fences given in arrays hFences and vFences respectively.\n\nHorizontal fences are from the coordinates (hFences[i], 1) to (hFences[i], n) and vertical fences are from the coordinates (1, vFences[i]) to (m, vFences[i]).\n\nReturn the maximum area of a square field that can be formed by removing some fences (possibly none) or -1 if it is impossible to make a square field.\n\nSince the answer may be large, return it modulo 109 + 7.\n\nNote: The field is surrounded by two horizontal fences from the coordinates (1, 1) to (1, n) and (m, 1) to (m, n) and two vertical fences from the coordinates (1, 1) to (m, 1) and (1, n) to (m, n). These fences cannot be removed.\n\n \nExample 1:\n\n\n\nInput: m = 4, n = 3, hFences = [2,3], vFences = [2]\nOutput: 4\nExplanation: Removing the horizontal fence at 2 and the vertical fence at 2 will give a square field of area 4.\n\n\nExample 2:\n\n\n\nInput: m = 6, n = 7, hFences = [2], vFences = [4]\nOutput: -1\nExplanation: It can be proved that there is no way to create a square field by removing fences.\n\n\n \nConstraints:\n\n\n\t3 <= m, n <= 109\n\t1 <= hFences.length, vFences.length <= 600\n\t1 < hFences[i] < m\n\t1 < vFences[i] < n\n\thFences and vFences are unique.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-16T16:33:37.000Z"
    },
    {
      "id": "leetcode-medium-minimize-maximum-pair-sum-in-array",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Minimize Maximum Pair Sum in Array",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int minPairSum(int[] nums) {\n        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\n        int[] freq = new int[100001];\n        for(int i = 0; i < nums.length; i++) {\n            if(nums[i] < min) min = nums[i];\n            if(nums[i] > max) max = nums[i];\n            freq[nums[i]]++;\n        }\n        int max_sum = 0, l = min, r = max;\n        while(l <= r) {\n            if(freq[l] == 0) l++;\n            else if(freq[r] == 0) r--;\n            else {\n                max_sum = Math.max(max_sum, l + r);\n                freq[l]--;\n                freq[r]--;\n            }\n        }\n        return max_sum;\n    }\n}",
        "readme": "ArrayTwoPointersGreedySortingBiweeklyContest53\n\nThe pair sum of a pair (a,b) is equal to a + b. The maximum pair sum is the largest pair sum in a list of pairs.\n\n\n\tFor example, if we have pairs (1,5), (2,3), and (4,4), the maximum pair sum would be max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8.\n\n\nGiven an array nums of even length n, pair up the elements of nums into n / 2 pairs such that:\n\n\n\tEach element of nums is in exactly one pair, and\n\tThe maximum pair sum is minimized.\n\n\nReturn the minimized maximum pair sum after optimally pairing up the elements.\n\n \nExample 1:\n\nInput: nums = [3,5,2,3]\nOutput: 7\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\n\n\nExample 2:\n\nInput: nums = [3,5,4,2,4,6]\nOutput: 8\nExplanation: The elements can be paired up into pairs (3,5), (4,4), and (6,2).\nThe maximum pair sum is max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8.\n\n\n \nConstraints:\n\n\n\tn == nums.length\n\t2 <= n <= 105\n\tn is even.\n\t1 <= nums[i] <= 105",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-24T17:23:27.000Z"
    },
    {
      "id": "leetcode-medium-minimum-cost-path-with-edge-reversals",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Minimum Cost Path with Edge Reversals",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int minCost(int n, int[][] edges) {\n        List<int[]>[] graph = new ArrayList[n];\n        for (int i = 0; i < n; i++) graph[i] = new ArrayList<>();\n\n        for (int[] e : edges) {\n            graph[e[0]].add(new int[]{e[1], e[2]});\n            graph[e[1]].add(new int[]{e[0], 2 * e[2]});\n        }\n\n        long[] dist = new long[n];\n        Arrays.fill(dist, Long.MAX_VALUE);\n        dist[0] = 0;\n\n        PriorityQueue<long[]> pq =\n            new PriorityQueue<>(Comparator.comparingLong(a -> a[0]));\n        pq.offer(new long[]{0, 0});\n\n        while (!pq.isEmpty()) {\n            long[] cur = pq.poll();\n            long cost = cur[0];\n            int node = (int) cur[1];\n\n            if (cost > dist[node]) continue;\n\n            for (int[] nxt : graph[node]) {\n                int v = nxt[0];\n                int w = nxt[1];\n                if (dist[v] > cost + w) {\n                    dist[v] = cost + w;\n                    pq.offer(new long[]{dist[v], v});\n                }\n            }\n        }\n\n        return dist[n - 1] == Long.MAX_VALUE ? -1 : (int) dist[n - 1];\n    }\n}",
        "readme": "GraphTheoryHeap(PriorityQueue)ShortestPathBiweeklyContest163\n\nYou are given a directed, weighted graph with n nodes labeled from 0 to n - 1, and an array edges where edges[i] = [ui, vi, wi] represents a directed edge from node ui to node vi with cost wi.\n\nEach node ui has a switch that can be used at most once: when you arrive at ui and have not yet used its switch, you may activate it on one of its incoming edges vi → ui reverse that edge to ui → vi and immediately traverse it.\n\nThe reversal is only valid for that single move, and using a reversed edge costs 2 * wi.\n\nReturn the minimum total cost to travel from node 0 to node n - 1. If it is not possible, return -1.\n\n \nExample 1:\n\n\nInput: n = 4, edges = [[0,1,3],[3,1,1],[2,3,4],[0,2,2]]\n\nOutput: 5\n\nExplanation: \n\n\n\n\n\tUse the path 0 → 1 (cost 3).\n\tAt node 1 reverse the original edge 3 → 1 into 1 → 3 and traverse it at cost 2 * 1 = 2.\n\tTotal cost is 3 + 2 = 5.\n\n\n\nExample 2:\n\n\nInput: n = 4, edges = [[0,2,1],[2,1,1],[1,3,1],[2,3,3]]\n\nOutput: 3\n\nExplanation:\n\n\n\tNo reversal is needed. Take the path 0 → 2 (cost 1), then 2 → 1 (cost 1), then 1 → 3 (cost 1).\n\tTotal cost is 1 + 1 + 1 = 3.\n\n\n\n \nConstraints:\n\n\n\t2 <= n <= 5 * 104\n\t1 <= edges.length <= 105\n\tedges[i] = [ui, vi, wi]\n\t0 <= ui, vi <= n - 1\n\t1 <= wi <= 1000",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-27T02:53:55.000Z"
    },
    {
      "id": "leetcode-medium-minimum-cost-to-convert-string-i",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Minimum Cost to Convert String I",
      "language": "java",
      "files": {
        "code": "import java.util.*;\n\nclass Solution {\n    private void dijkstra(int src, List<int[]>[] adj, int[] dist) {\n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));\n        dist[src] = 0;\n        pq.offer(new int[]{0, src});\n\n        while (!pq.isEmpty()) {\n            int[] cur = pq.poll();\n            int d = cur[0], u = cur[1];\n\n            if (d > dist[u]) continue;\n\n            for (int[] edge : adj[u]) {\n                int v = edge[0], w = edge[1];\n                if (dist[v] > d + w) {\n                    dist[v] = d + w;\n                    pq.offer(new int[]{dist[v], v});\n                }\n            }\n        }\n    }\n\n    public long minimumCost(String source, String target, char[] original, char[] changed, int[] cost) {\n        if (source.length() != target.length()) return -1;\n\n        List<int[]>[] adj = new ArrayList[26];\n        for (int i = 0; i < 26; i++) adj[i] = new ArrayList<>();\n\n        for (int i = 0; i < original.length; i++) {\n            adj[original[i] - 'a'].add(new int[]{changed[i] - 'a', cost[i]});\n        }\n\n        int[][] dist = new int[26][26];\n        for (int i = 0; i < 26; i++) {\n            Arrays.fill(dist[i], Integer.MAX_VALUE);\n            dijkstra(i, adj, dist[i]);\n        }\n\n        long ans = 0;\n        for (int i = 0; i < source.length(); i++) {\n            int u = source.charAt(i) - 'a';\n            int v = target.charAt(i) - 'a';\n            if (u == v) continue;\n            if (dist[u][v] == Integer.MAX_VALUE) return -1;\n            ans += dist[u][v];\n        }\n\n        return ans;\n    }\n}",
        "readme": "DailyCodingChallengeCompleted!,CompletionStreak:,197,Days,Consistencyiskey,seeyoutomorrow!\n\nYou are given two 0-indexed strings source and target, both of length n and consisting of lowercase English letters. You are also given two 0-indexed character arrays original and changed, and an integer array cost, where cost[i] represents the cost of changing the character original[i] to the character changed[i].\n\nYou start with the string source. In one operation, you can pick a character x from the string and change it to the character y at a cost of z if there exists any index j such that cost[j] == z, original[j] == x, and changed[j] == y.\n\nReturn the minimum cost to convert the string source to the string target using any number of operations. If it is impossible to convert source to target, return -1.\n\nNote that there may exist indices i, j such that original[j] == original[i] and changed[j] == changed[i].\n\n \nExample 1:\n\nInput: source = \"abcd\", target = \"acbe\", original = [\"a\",\"b\",\"c\",\"c\",\"e\",\"d\"], changed = [\"b\",\"c\",\"b\",\"e\",\"b\",\"e\"], cost = [2,5,5,1,2,20]\nOutput: 28\nExplanation: To convert the string \"abcd\" to string \"acbe\":\n- Change value at index 1 from 'b' to 'c' at a cost of 5.\n- Change value at index 2 from 'c' to 'e' at a cost of 1.\n- Change value at index 2 from 'e' to 'b' at a cost of 2.\n- Change value at index 3 from 'd' to 'e' at a cost of 20.\nThe total cost incurred is 5 + 1 + 2 + 20 = 28.\nIt can be shown that this is the minimum possible cost.\n\n\nExample 2:\n\nInput: source = \"aaaa\", target = \"bbbb\", original = [\"a\",\"c\"], changed = [\"c\",\"b\"], cost = [1,2]\nOutput: 12\nExplanation: To change the character 'a' to 'b' change the character 'a' to 'c' at a cost of 1, followed by changing the character 'c' to 'b' at a cost of 2, for a total cost of 1 + 2 = 3. To change all occurrences of 'a' to 'b', a total cost of 3 * 4 = 12 is incurred.\n\n\nExample 3:\n\nInput: source = \"abcd\", target = \"abce\", original = [\"a\"], changed = [\"e\"], cost = [10000]\nOutput: -1\nExplanation: It is impossible to convert source to target because the value at index 3 cannot be changed from 'd' to 'e'.\n\n\n \nConstraints:\n\n\n\t1 <= source.length == target.length <= 105\n\tsource, target consist of lowercase English letters.\n\t1 <= cost.length == original.length == changed.length <= 2000\n\toriginal[i], changed[i] are lowercase English letters.\n\t1 <= cost[i] <= 106\n\toriginal[i] != changed[i]",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-29T09:18:58.000Z"
    },
    {
      "id": "leetcode-medium-minimum-removals-to-balance-array",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Minimum Removals to Balance Array",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int minRemoval(int[] nums, int k) {\n        int n = nums.length;\n        Arrays.sort(nums);\n        int ans = 0;\n        for(int i = 0, j = 0; i < n; i ++){\n            while(j + 1 < n && (long) nums[i] * (long) k >= nums[j + 1]){\n                j++;\n            }\n            ans = Math.max(ans, j - i + 1);\n        }\n        return n - ans;\n    }\n}",
        "readme": "SeniorArraySlidingWindowSortingBiweeklyContest162\n\nYou are given an integer array nums and an integer k.\n\nAn array is considered balanced if the value of its maximum element is at most k times the minimum element.\n\nYou may remove any number of elements from nums​​​​​​​ without making it empty.\n\nReturn the minimum number of elements to remove so that the remaining array is balanced.\n\nNote: An array of size 1 is considered balanced as its maximum and minimum are equal, and the condition always holds true.\n\n \nExample 1:\n\n\nInput: nums = [2,1,5], k = 2\n\nOutput: 1\n\nExplanation:\n\n\n\tRemove nums[2] = 5 to get nums = [2, 1].\n\tNow max = 2, min = 1 and max <= min * k as 2 <= 1 * 2. Thus, the answer is 1.\n\n\n\nExample 2:\n\n\nInput: nums = [1,6,2,9], k = 3\n\nOutput: 2\n\nExplanation:\n\n\n\tRemove nums[0] = 1 and nums[3] = 9 to get nums = [6, 2].\n\tNow max = 6, min = 2 and max <= min * k as 6 <= 2 * 3. Thus, the answer is 2.\n\n\n\nExample 3:\n\n\nInput: nums = [4,6], k = 2\n\nOutput: 0\n\nExplanation:\n\n\n\tSince nums is already balanced as 6 <= 4 * 2, no elements need to be removed.\n\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 105\n\t1 <= nums[i] <= 109\n\t1 <= k <= 105",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-02-06T07:53:13.000Z"
    },
    {
      "id": "leetcode-medium-separate-squares-i",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Separate Squares I",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public double separateSquares(int[][] squares) {\n        List<double[]> events = new ArrayList<>(); \n\n        for (int[] sq : squares) {\n            int yi = sq[1], li = sq[2];\n\n            events.add(new double[]{yi, li});\n            events.add(new double[]{yi + li, -li});\n        }\n\n        events.sort((a, b) -> Double.compare(a[0], b[0]));\n\n        double total_w = 0.0;\n        for (int[] sq : squares) {\n            int li = sq[2];\n            total_w += (double)li * li;\n        }\n\n        double target = total_w / 2.0;\n\n        double curr_y = events.get(0)[0], curr_w = 0.0, accumulated = 0.0;\n\n        for (int i = 0; i < events.size(); i++) {\n            double[] event = events.get(i);\n            double y = event[0], change = event[1];\n\n            double separate = y - curr_y;\n            accumulated += curr_w * separate;\n            \n            if (accumulated >= target) {\n                double prev = accumulated - curr_w * separate;\n\n                double need = target - prev;\n                return curr_y + need / curr_w;\n            }\n\n            curr_y = y;\n            curr_w += change;\n        }\n\n        return 0.0;\n    }\n}",
        "readme": "",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": false,
      "hasNotes": false,
      "lastUpdated": "2026-01-13T15:45:50.000Z"
    },
    {
      "id": "leetcode-hard-divide-an-array-into-subarrays-with-minimum-cost-ii",
      "platform": "Leetcode",
      "difficulty": "Hard",
      "problemName": "Divide an Array Into Subarrays With Minimum Cost II",
      "language": "java",
      "files": {
        "code": "class Solution {\n\n    public long minimumCost(int[] nums, int k, int dist) {\n\n        int n = nums.length;\n        long result = Long.MAX_VALUE;\n        long windowSum = 0L;\n\n        java.util.TreeSet<Integer> using = new java.util.TreeSet<>(\n                (a, b) -> nums[a] == nums[b] ? a - b : nums[a] - nums[b]\n        );\n\n        java.util.TreeSet<Integer> waiting = new java.util.TreeSet<>(\n                (a, b) -> nums[a] == nums[b] ? a - b : nums[a] - nums[b]\n        );\n\n        for (int i = 1; i <= dist + 1; i++) {\n            using.add(i);\n            windowSum += nums[i];\n        }\n\n        while (using.size() > k - 1) {\n            int idx = using.pollLast();\n            windowSum -= nums[idx];\n            waiting.add(idx);\n        }\n\n        result = Math.min(result, windowSum);\n\n        for (int i = 1; i + dist + 1 < n; i++) {\n\n            waiting.add(i + dist + 1);\n\n            if (using.contains(i)) {\n                using.remove(i);\n                windowSum -= nums[i];\n\n                int idx = waiting.pollFirst();\n                using.add(idx);\n                windowSum += nums[idx];\n\n            } else {\n                waiting.remove(i);\n\n                int wMin = waiting.first();\n                int uMax = using.last();\n\n                if (nums[wMin] < nums[uMax]) {\n                    using.remove(uMax);\n                    waiting.add(uMax);\n                    windowSum -= nums[uMax];\n\n                    waiting.remove(wMin);\n                    using.add(wMin);\n                    windowSum += nums[wMin];\n                }\n            }\n\n            result = Math.min(result, windowSum);\n        }\n\n        return result + nums[0];\n    }\n}",
        "readme": "ArrayHashTableSlidingWindowHeap(PriorityQueue)BiweeklyContest122\n\nYou are given a 0-indexed array of integers nums of length n, and two positive integers k and dist.\n\nThe cost of an array is the value of its first element. For example, the cost of [1,2,3] is 1 while the cost of [3,4,1] is 3.\n\nYou need to divide nums into k disjoint contiguous subarrays, such that the difference between the starting index of the second subarray and the starting index of the kth subarray should be less than or equal to dist. In other words, if you divide nums into the subarrays nums[0..(i1 - 1)], nums[i1..(i2 - 1)], ..., nums[ik-1..(n - 1)], then ik-1 - i1 <= dist.\n\nReturn the minimum possible sum of the cost of these subarrays.\n\n \nExample 1:\n\nInput: nums = [1,3,2,6,4,2], k = 3, dist = 3\nOutput: 5\nExplanation: The best possible way to divide nums into 3 subarrays is: [1,3], [2,6,4], and [2]. This choice is valid because ik-1 - i1 is 5 - 2 = 3 which is equal to dist. The total cost is nums[0] + nums[2] + nums[5] which is 1 + 2 + 2 = 5.\nIt can be shown that there is no possible way to divide nums into 3 subarrays at a cost lower than 5.\n\n\nExample 2:\n\nInput: nums = [10,1,2,2,2,1], k = 4, dist = 3\nOutput: 15\nExplanation: The best possible way to divide nums into 4 subarrays is: [10], [1], [2], and [2,2,1]. This choice is valid because ik-1 - i1 is 3 - 1 = 2 which is less than dist. The total cost is nums[0] + nums[1] + nums[2] + nums[3] which is 10 + 1 + 2 + 2 = 15.\nThe division [10], [1], [2,2,2], and [1] is not valid, because the difference between ik-1 and i1 is 5 - 1 = 4, which is greater than dist.\nIt can be shown that there is no possible way to divide nums into 4 subarrays at a cost lower than 15.\n\n\nExample 3:\n\nInput: nums = [10,8,18,9], k = 3, dist = 1\nOutput: 36\nExplanation: The best possible way to divide nums into 4 subarrays is: [10], [8], and [18,9]. This choice is valid because ik-1 - i1 is 2 - 1 = 1 which is equal to dist.The total cost is nums[0] + nums[1] + nums[2] which is 10 + 8 + 18 = 36.\nThe division [10], [8,18], and [9] is not valid, because the difference between ik-1 and i1 is 3 - 1 = 2, which is greater than dist.\nIt can be shown that there is no possible way to divide nums into 3 subarrays at a cost lower than 36.\n\n\n \nConstraints:\n\n\n\t3 <= n <= 105\n\t1 <= nums[i] <= 109\n\t3 <= k <= n\n\tk - 2 <= dist <= n - 2",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-02-02T07:30:50.000Z"
    },
    {
      "id": "leetcode-hard-last-day-where-you-can-still-cross",
      "platform": "Leetcode",
      "difficulty": "Hard",
      "problemName": "Last Day Where You Can Still Cross",
      "language": "java",
      "files": {
        "code": "class Solution {\n    private int[][] directions = {{1,0},{-1,0},{0,1},{0,-1}};\n    private int rows, cols;\n    public int latestDayToCross(int row, int col, int[][] cells) {\n        this.rows = row;\n        this.cols = col;\n        int left = 1, right = cells.length, answer = 0;\n        while (left<=right){\n            int mid=left+(right-left)/2;\n            if(canCross(mid,cells)){\n                answer=mid;\n                left=mid+1;\n            } else{\n                right=mid-1;\n            }\n        }\n        return answer;\n    }\n    \n    private boolean canCross(int day, int[][] cells) {\n        int[][] grid = new int[rows][cols];\n        \n        for (int i = 0; i < day; i++) {\n            grid[cells[i][0] - 1][cells[i][1] - 1] = 1;\n        }\n        \n        Queue<int[]> queue = new LinkedList<>();\n        boolean[][] visited = new boolean[rows][cols];\n        \n        for (int c = 0; c < cols; c++) {\n            if (grid[0][c] == 0) {\n                queue.offer(new int[]{0, c});\n                visited[0][c] = true;\n            }\n        }\n        \n        while (!queue.isEmpty()) {\n            int[] curr = queue.poll();\n            int r = curr[0], c = curr[1];\n            \n            if (r == rows - 1) return true;\n            \n            for (int[] dir : directions) {\n                int nr = r + dir[0];\n                int nc = c + dir[1];\n                \n                if (nr>=0&&nr<rows&&nc>=0&&nc<cols&&!visited[nr][nc]&&grid[nr][nc]==0){\n                    visited[nr][nc]=true;\n                    queue.offer(new int[]{nr,nc});\n                }\n            }\n        }\n        return false;\n    }\n}",
        "readme": "DailyCodingChallengeCompleted!,YouhavebeenawardedDCCDecember2025!,Consistencyiskey,seeyounextmonth!\n\nThere is a 1-based binary matrix where 0 represents land and 1 represents water. You are given integers row and col representing the number of rows and columns in the matrix, respectively.\n\nInitially on day 0, the entire matrix is land. However, each day a new cell becomes flooded with water. You are given a 1-based 2D array cells, where cells[i] = [ri, ci] represents that on the ith day, the cell on the rith row and cith column (1-based coordinates) will be covered with water (i.e., changed to 1).\n\nYou want to find the last day that it is possible to walk from the top to the bottom by only walking on land cells. You can start from any cell in the top row and end at any cell in the bottom row. You can only travel in the four cardinal directions (left, right, up, and down).\n\nReturn the last day where it is possible to walk from the top to the bottom by only walking on land cells.\n\n \nExample 1:\n\nInput: row = 2, col = 2, cells = [[1,1],[2,1],[1,2],[2,2]]\nOutput: 2\nExplanation: The above image depicts how the matrix changes each day starting from day 0.\nThe last day where it is possible to cross from top to bottom is on day 2.\n\n\nExample 2:\n\nInput: row = 2, col = 2, cells = [[1,1],[1,2],[2,1],[2,2]]\nOutput: 1\nExplanation: The above image depicts how the matrix changes each day starting from day 0.\nThe last day where it is possible to cross from top to bottom is on day 1.\n\n\nExample 3:\n\nInput: row = 3, col = 3, cells = [[1,2],[2,1],[3,3],[2,2],[1,1],[1,3],[2,3],[3,2],[3,1]]\nOutput: 3\nExplanation: The above image depicts how the matrix changes each day starting from day 0.\nThe last day where it is possible to cross from top to bottom is on day 3.\n\n\n \nConstraints:\n\n\n\t2 <= row, col <= 2 * 104\n\t4 <= row * col <= 2 * 104\n\tcells.length == row * col\n\t1 <= ri <= row\n\t1 <= ci <= col\n\tAll the values of cells are unique.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-12-31T14:04:33.000Z"
    },
    {
      "id": "leetcode-hard-max-dot-product-of-two-subsequences",
      "platform": "Leetcode",
      "difficulty": "Hard",
      "problemName": "Max Dot Product of Two Subsequences",
      "language": "java",
      "files": {
        "code": "class Solution {\n\n    // dp[i][j] stores the maximum dot product for nums1[0..i] and nums2[0..j]\n    Integer[][] dp;\n\n    public int maxDotProduct(int[] nums1, int[] nums2) {\n        dp = new Integer[nums1.length][nums2.length];\n        return solve(nums1, nums2, nums1.length - 1, nums2.length - 1);\n    }\n\n    private int solve(int[] nums1, int[] nums2, int i, int j) {\n\n        // Base case: if either array is exhausted\n        if (i < 0 || j < 0) {\n            return Integer.MIN_VALUE; // invalid (non-empty constraint)\n        }\n\n        // If already computed, reuse it\n        if (dp[i][j] != null) {\n            return dp[i][j];\n        }\n\n        // Option 1: take current pair\n        int product = nums1[i] * nums2[j];\n\n        // Option 2: extend a previous subsequence\n        int extend = solve(nums1, nums2, i - 1, j - 1);\n        int take = product;\n        if (extend != Integer.MIN_VALUE) {\n            take = Math.max(take, product + extend);\n        }\n\n        // Option 3: skip one element\n        int skip = Math.max(\n            solve(nums1, nums2, i - 1, j),\n            solve(nums1, nums2, i, j - 1)\n        );\n\n        // Store and return the best result\n        return dp[i][j] = Math.max(take, skip);\n    }\n}",
        "readme": "DailyCodingChallengeCompleted!,CompletionStreak:,176,Days,Consistencyiskey,seeyoutomorrow!\n\nGiven two arrays nums1 and nums2.\n\nReturn the maximum dot product between non-empty subsequences of nums1 and nums2 with the same length.\n\nA subsequence of a array is a new array which is formed from the original array by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, [2,3,5] is a subsequence of [1,2,3,4,5] while [1,5,3] is not).\n\n \nExample 1:\n\nInput: nums1 = [2,1,-2,5], nums2 = [3,0,-6]\nOutput: 18\nExplanation: Take subsequence [2,-2] from nums1 and subsequence [3,-6] from nums2.\nTheir dot product is (2*3 + (-2)*(-6)) = 18.\n\nExample 2:\n\nInput: nums1 = [3,-2], nums2 = [2,-6,7]\nOutput: 21\nExplanation: Take subsequence [3] from nums1 and subsequence [7] from nums2.\nTheir dot product is (3*7) = 21.\n\nExample 3:\n\nInput: nums1 = [-1,-1], nums2 = [1,1]\nOutput: -1\nExplanation: Take subsequence [-1] from nums1 and subsequence [1] from nums2.\nTheir dot product is -1.\n\n \nConstraints:\n\n\n\t1 <= nums1.length, nums2.length <= 500\n\t-1000 <= nums1[i], nums2[i] <= 1000",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-08T05:38:27.000Z"
    },
    {
      "id": "leetcode-hard-maximal-rectangle",
      "platform": "Leetcode",
      "difficulty": "Hard",
      "problemName": "Maximal Rectangle",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int maximalRectangle(char[][] matrix) {\n        int m = matrix.length, n = matrix[0].length, ans = 0;\n        int[]hist = new int[n];\n\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(matrix[i][j]!='0')hist[j]+=1;\n                else hist[j] = 0;\n            }\n            int area = area(hist);\n            ans = Math.max(ans, area);\n        }\n\n        return ans;\n       \n    }\n\n    public static int area(int[] heights) {\n        int n = heights.length;\n        int maxArea = 0;\n        Stack<Integer> stack = new Stack<>();\n\n        for (int i = 0; i <= n; i++) {\n            int h = (i == n) ? 0 : heights[i];\n            while (!stack.isEmpty() && h < heights[stack.peek()]) {\n                int height = heights[stack.pop()];\n                int width = stack.isEmpty() ? i : i - stack.peek() - 1;\n                maxArea = Math.max(maxArea, height * width);\n            }\n            stack.push(i);\n        }\n\n        return maxArea;\n    }\n}",
        "readme": "DailyCodingChallengeCompleted!,CompletionStreak:,179,Days,Consistencyiskey,seeyoutomorrow!\n\nGiven a rows x cols binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.\n\n \nExample 1:\n\nInput: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\nOutput: 6\nExplanation: The maximal rectangle is shown in the above picture.\n\n\nExample 2:\n\nInput: matrix = [[\"0\"]]\nOutput: 0\n\n\nExample 3:\n\nInput: matrix = [[\"1\"]]\nOutput: 1\n\n\n \nConstraints:\n\n\n\trows == matrix.length\n\tcols == matrix[i].length\n\t1 <= rows, cols <= 200\n\tmatrix[i][j] is '0' or '1'.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-11T14:18:18.000Z"
    },
    {
      "id": "leetcode-hard-minimum-cost-path-with-teleportations",
      "platform": "Leetcode",
      "difficulty": "Hard",
      "problemName": "Minimum Cost Path with Teleportations",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int minCost(int[][] grid, int k) {\n        int n = grid.length, m = grid[0].length;\n        \n        // 1. Find the Maximum Value in the grid to size our helper arrays\n        int maxVal = 0;\n        for(int[] row : grid) {\n            for(int val : row) maxVal = Math.max(maxVal, val);\n        }\n\n        // dp[i][j] = Min cost to reach (n-1, m-1) from (i, j)\n        int[][] dp = new int[n][m];\n        \n        // temp[v] = Min cost starting from ANY cell with value 'v'\n        int[] temp = new int[maxVal + 1];\n        int[] best = new int[maxVal + 1];\n        \n        Arrays.fill(temp, Integer.MAX_VALUE);\n        \n        // Base Case: Cost from target to target is 0. \n        // Note: The cost is incurred when ENTERING a cell. \n        // We consider the target reached, so starting at target has 0 *additional* cost.\n        temp[grid[n - 1][m - 1]] = 0;\n\n        // --- INITIALIZATION (K=0) ---\n        // Fill DP table using standard walking rules (Right/Down)\n        for(int i = n - 1; i >= 0; i--) {\n            for(int j = m - 1; j >= 0; j--) {\n                if(i == n - 1 && j == m - 1) continue; // Skip target\n                \n                int down = (i + 1 < n) ? dp[i + 1][j] + grid[i + 1][j] : Integer.MAX_VALUE;\n                int right = (j + 1 < m) ? dp[i][j + 1] + grid[i][j + 1] : Integer.MAX_VALUE;\n                \n                dp[i][j] = Math.min(down, right);\n                \n                // Update the best known cost for this cell's value\n                if (dp[i][j] != Integer.MAX_VALUE) {\n                    temp[grid[i][j]] = Math.min(temp[grid[i][j]], dp[i][j]);\n                }\n            }\n        }\n\n        // --- LAYERS (K > 0) ---\n        // For each allowed teleport, we try to relax the grid costs\n        for(int x = 0; x < k; x++) {\n            \n            // 1. Build Prefix Minimum Array\n            // best[v] = min cost obtainable from any cell with value <= v\n            best[0] = temp[0];\n            for(int v = 1; v <= maxVal; v++) {\n                best[v] = Math.min(best[v - 1], temp[v]);\n            }\n            \n            // 2. Update DP Table with Teleport Options\n            for(int i = n - 1; i >= 0; i--) {\n                for(int j = m - 1; j >= 0; j--) {\n                    if(i == n - 1 && j == m - 1) continue;\n                    \n                    int down = (i + 1 < n) ? dp[i + 1][j] + grid[i + 1][j] : Integer.MAX_VALUE;\n                    int right = (j + 1 < m) ? dp[i][j + 1] + grid[i][j + 1] : Integer.MAX_VALUE;\n                    int walkCost = Math.min(down, right);\n                    \n                    // Teleport Option: Jump to the best state with value <= grid[i][j]\n                    int teleportCost = best[grid[i][j]];\n                    \n                    dp[i][j] = Math.min(walkCost, teleportCost);\n                    \n                    // Update temp for the NEXT iteration\n                    if (dp[i][j] != Integer.MAX_VALUE) {\n                        temp[grid[i][j]] = Math.min(temp[grid[i][j]], dp[i][j]);\n                    }\n                }\n            }\n        }\n        \n        return dp[0][0];\n    }\n}",
        "readme": "ArrayDynamicProgrammingMatrixBiweeklyContest163\n\nYou are given a m x n 2D integer array grid and an integer k. You start at the top-left cell (0, 0) and your goal is to reach the bottom‐right cell (m - 1, n - 1).\n\nThere are two types of moves available:\n\n\n\t\n\tNormal move: You can move right or down from your current cell (i, j), i.e. you can move to (i, j + 1) (right) or (i + 1, j) (down). The cost is the value of the destination cell.\n\t\n\t\n\tTeleportation: You can teleport from any cell (i, j), to any cell (x, y) such that grid[x][y] <= grid[i][j]; the cost of this move is 0. You may teleport at most k times.\n\t\n\n\nReturn the minimum total cost to reach cell (m - 1, n - 1) from (0, 0).\n\n \nExample 1:\n\n\nInput: grid = [[1,3,3],[2,5,4],[4,3,5]], k = 2\n\nOutput: 7\n\nExplanation:\n\nInitially we are at (0, 0) and cost is 0.\n\nCurrent PositionMoveNew PositionTotal Cost(0, 0)Move Down(1, 0)0 + 2 = 2(1, 0)Move Right(1, 1)2 + 5 = 7(1, 1)Teleport to (2, 2)(2, 2)7 + 0 = 7\n\nThe minimum cost to reach bottom-right cell is 7.\n\n\nExample 2:\n\n\nInput: grid = [[1,2],[2,3],[3,4]], k = 1\n\nOutput: 9\n\nExplanation: \n\nInitially we are at (0, 0) and cost is 0.\n\nCurrent PositionMoveNew PositionTotal Cost(0, 0)Move Down(1, 0)0 + 2 = 2(1, 0)Move Right(1, 1)2 + 3 = 5(1, 1)Move Down(2, 1)5 + 4 = 9\n\nThe minimum cost to reach bottom-right cell is 9.\n\n\n \nConstraints:\n\n\n\t2 <= m, n <= 80\n\tm == grid.length\n\tn == grid[i].length\n\t0 <= grid[i][j] <= 104\n\t0 <= k <= 10",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-28T07:33:21.000Z"
    },
    {
      "id": "leetcode-hard-minimum-cost-to-convert-string-ii",
      "platform": "Leetcode",
      "difficulty": "Hard",
      "problemName": "Minimum Cost to Convert String II",
      "language": "java",
      "files": {
        "code": "import java.util.*;\n\nclass Solution {\n    public long minimumCost(String source, String target, String[] original, String[] changed, int[] cost) {\n        int n = source.length();\n        Map<String, Integer> strToId = new HashMap<>();\n        int idCounter = 0;\n\n        for (String s : original) if (!strToId.containsKey(s)) strToId.put(s, idCounter++);\n        for (String s : changed) if (!strToId.containsKey(s)) strToId.put(s, idCounter++);\n\n        long INF = 1_000_000_000_000_000L;\n        long[][] dist = new long[idCounter][idCounter];\n        for (int i = 0; i < idCounter; i++) {\n            Arrays.fill(dist[i], INF);\n            dist[i][i] = 0;\n        }\n\n        for (int i = 0; i < original.length; i++) {\n            int u = strToId.get(original[i]);\n            int v = strToId.get(changed[i]);\n            dist[u][v] = Math.min(dist[u][v], (long) cost[i]);\n        }\n\n        // Floyd-Warshall\n        for (int k = 0; k < idCounter; k++) {\n            for (int i = 0; i < idCounter; i++) {\n                for (int j = 0; j < idCounter; j++) {\n                    if (dist[i][k] < INF && dist[k][j] < INF) {\n                        dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);\n                    }\n                }\n            }\n        }\n\n        long[] dp = new long[n + 1];\n        Arrays.fill(dp, INF);\n        dp[0] = 0;\n\n        Set<Integer> uniqueLens = new HashSet<>();\n        for (String s : original) uniqueLens.add(s.length());\n        Integer[] lens = uniqueLens.toArray(new Integer[0]);\n\n        for (int i = 0; i < n; i++) {\n            if (dp[i] == INF) continue;\n\n            if (source.charAt(i) == target.charAt(i)) {\n                dp[i + 1] = Math.min(dp[i + 1], dp[i]);\n            }\n\n            for (int len : lens) {\n                if (i + len <= n) {\n                    String subS = source.substring(i, i + len);\n                    String subT = target.substring(i, i + len);\n\n                    if (subS.equals(subT)) {\n                        dp[i + len] = Math.min(dp[i + len], dp[i]);\n                    } else if (strToId.containsKey(subS) && strToId.containsKey(subT)) {\n                        int u = strToId.get(subS);\n                        int v = strToId.get(subT);\n                        if (dist[u][v] < INF) {\n                            dp[i + len] = Math.min(dp[i + len], dp[i] + dist[u][v]);\n                        }\n                    }\n                }\n            }\n        }\n\n        return dp[n] >= INF ? -1 : dp[n];\n    }\n}",
        "readme": "ArrayStringDynamicProgrammingGraphTheoryTrieShortestPathWeeklyContest377\n\nYou are given two 0-indexed strings source and target, both of length n and consisting of lowercase English characters. You are also given two 0-indexed string arrays original and changed, and an integer array cost, where cost[i] represents the cost of converting the string original[i] to the string changed[i].\n\nYou start with the string source. In one operation, you can pick a substring x from the string, and change it to y at a cost of z if there exists any index j such that cost[j] == z, original[j] == x, and changed[j] == y. You are allowed to do any number of operations, but any pair of operations must satisfy either of these two conditions:\n\n\n\tThe substrings picked in the operations are source[a..b] and source[c..d] with either b < c or d < a. In other words, the indices picked in both operations are disjoint.\n\tThe substrings picked in the operations are source[a..b] and source[c..d] with a == c and b == d. In other words, the indices picked in both operations are identical.\n\n\nReturn the minimum cost to convert the string source to the string target using any number of operations. If it is impossible to convert source to target, return -1.\n\nNote that there may exist indices i, j such that original[j] == original[i] and changed[j] == changed[i].\n\n \nExample 1:\n\nInput: source = \"abcd\", target = \"acbe\", original = [\"a\",\"b\",\"c\",\"c\",\"e\",\"d\"], changed = [\"b\",\"c\",\"b\",\"e\",\"b\",\"e\"], cost = [2,5,5,1,2,20]\nOutput: 28\nExplanation: To convert \"abcd\" to \"acbe\", do the following operations:\n- Change substring source[1..1] from \"b\" to \"c\" at a cost of 5.\n- Change substring source[2..2] from \"c\" to \"e\" at a cost of 1.\n- Change substring source[2..2] from \"e\" to \"b\" at a cost of 2.\n- Change substring source[3..3] from \"d\" to \"e\" at a cost of 20.\nThe total cost incurred is 5 + 1 + 2 + 20 = 28. \nIt can be shown that this is the minimum possible cost.\n\n\nExample 2:\n\nInput: source = \"abcdefgh\", target = \"acdeeghh\", original = [\"bcd\",\"fgh\",\"thh\"], changed = [\"cde\",\"thh\",\"ghh\"], cost = [1,3,5]\nOutput: 9\nExplanation: To convert \"abcdefgh\" to \"acdeeghh\", do the following operations:\n- Change substring source[1..3] from \"bcd\" to \"cde\" at a cost of 1.\n- Change substring source[5..7] from \"fgh\" to \"thh\" at a cost of 3. We can do this operation because indices [5,7] are disjoint with indices picked in the first operation.\n- Change substring source[5..7] from \"thh\" to \"ghh\" at a cost of 5. We can do this operation because indices [5,7] are disjoint with indices picked in the first operation, and identical with indices picked in the second operation.\nThe total cost incurred is 1 + 3 + 5 = 9.\nIt can be shown that this is the minimum possible cost.\n\n\nExample 3:\n\nInput: source = \"abcdefgh\", target = \"addddddd\", original = [\"bcd\",\"defgh\"], changed = [\"ddd\",\"ddddd\"], cost = [100,1578]\nOutput: -1\nExplanation: It is impossible to convert \"abcdefgh\" to \"addddddd\".\nIf you select substring source[1..3] as the first operation to change \"abcdefgh\" to \"adddefgh\", you cannot select substring source[3..7] as the second operation because it has a common index, 3, with the first operation.\nIf you select substring source[3..7] as the first operation to change \"abcdefgh\" to \"abcddddd\", you cannot select substring source[1..3] as the second operation because it has a common index, 3, with the first operation.\n\n\n \nConstraints:\n\n\n\t1 <= source.length == target.length <= 1000\n\tsource, target consist only of lowercase English characters.\n\t1 <= cost.length == original.length == changed.length <= 100\n\t1 <= original[i].length == changed[i].length <= source.length\n\toriginal[i], changed[i] consist only of lowercase English characters.\n\toriginal[i] != changed[i]\n\t1 <= cost[i] <= 106",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-30T07:58:23.000Z"
    },
    {
      "id": "leetcode-hard-minimum-pair-removal-to-sort-array-ii",
      "platform": "Leetcode",
      "difficulty": "Hard",
      "problemName": "Minimum Pair Removal to Sort Array II",
      "language": "java",
      "files": {
        "code": "class Solution {\n\n  private static class Segment implements Comparable<Segment> {\n      int index;\n      long value;\n      long mergeCost;\n      Segment left;\n      Segment right;\n\n      Segment(int idx, long val) {\n          index = idx;\n          value = val;\n      }\n\n      @Override\n      public int compareTo(Segment o) {\n          if (right == null || o.right == null) {\n              return right == null ? 1 : -1;\n          }\n          long diff = mergeCost - o.mergeCost;\n          if (diff != 0) return diff < 0 ? -1 : 1;\n          return index - o.index;\n      }\n  }\n\n  public int minimumPairRemoval(int[] nums) {\n      TreeSet<Segment> heap = new TreeSet<>();\n      int violations = 0;\n\n      Segment current = null;\n\n      for (int i = 0; i < nums.length; i++) {\n          Segment node = new Segment(i, nums[i]);\n\n          if (current != null) {\n              if (node.value < current.value) violations++;\n\n              current.right = node;\n              node.left = current;\n\n              current.mergeCost = current.value + node.value;\n              heap.add(current);\n          }\n          current = node;\n      }\n\n      heap.add(current);\n\n      int operations = 0;\n\n      while (violations > 0) {\n          operations++;\n\n          Segment best = heap.pollFirst();\n          Segment next = best.right;\n\n          if (next.value < best.value) violations--;\n\n          best.value += next.value;\n          best.mergeCost = best.value + (next.right != null ? next.right.value : 0);\n\n          best.right = next.right;\n          if (next.right != null) {\n              if (next.right.value < next.value) violations--;\n              next.right.left = best;\n              if (best.value > next.right.value) violations++;\n          }\n\n          heap.remove(next);\n          heap.add(best);\n\n          Segment prev = best.left;\n          if (prev != null) {\n              heap.remove(prev);\n\n              if (prev.value > prev.mergeCost - prev.value) violations--;\n              if (prev.value > best.value) violations++;\n\n              prev.mergeCost = prev.value + best.value;\n              prev.right = best;\n\n              heap.add(prev);\n          }\n      }\n\n      return operations;\n  }\n}",
        "readme": "ArrayHashTableLinkedListHeap(PriorityQueue)SimulationDoubly-LinkedListOrderedSetWeeklyContest444\n\nGiven an array nums, you can perform the following operation any number of times:\n\n\n\tSelect the adjacent pair with the minimum sum in nums. If multiple such pairs exist, choose the leftmost one.\n\tReplace the pair with their sum.\n\n\nReturn the minimum number of operations needed to make the array non-decreasing.\n\nAn array is said to be non-decreasing if each element is greater than or equal to its previous element (if it exists).\n\n \nExample 1:\n\n\nInput: nums = [5,2,3,1]\n\nOutput: 2\n\nExplanation:\n\n\n\tThe pair (3,1) has the minimum sum of 4. After replacement, nums = [5,2,4].\n\tThe pair (2,4) has the minimum sum of 6. After replacement, nums = [5,6].\n\n\nThe array nums became non-decreasing in two operations.\n\n\nExample 2:\n\n\nInput: nums = [1,2,2]\n\nOutput: 0\n\nExplanation:\n\nThe array nums is already sorted.\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 105\n\t-109 <= nums[i] <= 109",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-23T16:21:49.000Z"
    },
    {
      "id": "leetcode-hard-separate-squares-ii",
      "platform": "Leetcode",
      "difficulty": "Hard",
      "problemName": "Separate Squares II",
      "language": "java",
      "files": {
        "code": "import java.util.*;\n\nclass Solution {\n    // Helper class to represent active X-intervals\n    private static class Interval implements Comparable<Interval> {\n        int start, end;\n        \n        Interval(int start, int end) {\n            this.start = start;\n            this.end = end;\n        }\n        \n        // Needed for sort\n        public int compareTo(Interval other) {\n            if (this.start != other.start) return Integer.compare(this.start, other.start);\n            return Integer.compare(this.end, other.end);\n        }\n\n        // Needed for removing specific objects from ArrayList\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Interval interval = (Interval) o;\n            return start == interval.start && end == interval.end;\n        }\n    }\n\n    // Helper class for Sweep Line events\n    private static class Event implements Comparable<Event> {\n        int y;\n        int type; // 1 for start, -1 for end\n        int xStart, xEnd;\n\n        Event(int y, int type, int xStart, int xEnd) {\n            this.y = y;\n            this.type = type;\n            this.xStart = xStart;\n            this.xEnd = xEnd;\n        }\n\n        public int compareTo(Event other) {\n            return Integer.compare(this.y, other.y);\n        }\n    }\n\n    public double separateSquares(int[][] squares) {\n        List<Event> sweepEvents = new ArrayList<>();\n        for (int[] sq : squares) {\n            int x = sq[0];\n            int y = sq[1];\n            int l = sq[2];\n            sweepEvents.add(new Event(y, 1, x, x + l));\n            sweepEvents.add(new Event(y + l, -1, x, x + l));\n        }\n\n        Collections.sort(sweepEvents);\n\n        List<Interval> activeIntervals = new ArrayList<>();\n        // Store strips as: [y_bottom, height, union_width]\n        List<double[]> processedStrips = new ArrayList<>();\n        \n        double totalArea = 0;\n        int prevY = sweepEvents.get(0).y;\n\n        for (Event event : sweepEvents) {\n            // Process the gap (strip) between the previous event and this one\n            if (event.y > prevY) {\n                double unionWidth = getUnionWidth(activeIntervals);\n                double height = (double) event.y - prevY;\n                \n                if (unionWidth > 0) {\n                    processedStrips.add(new double[]{prevY, height, unionWidth});\n                    totalArea += height * unionWidth;\n                }\n            }\n\n            // Update active intervals list\n            Interval currentInterval = new Interval(event.xStart, event.xEnd);\n            if (event.type == 1) {\n                activeIntervals.add(currentInterval);\n            } else {\n                activeIntervals.remove(currentInterval);\n            }\n            \n            prevY = event.y;\n        }\n\n        // Second Pass: Find the split point\n        double targetArea = totalArea / 2.0;\n        double accumulatedArea = 0;\n\n        for (double[] strip : processedStrips) {\n            double bottomY = strip[0];\n            double height = strip[1];\n            double width = strip[2];\n            double stripArea = height * width;\n\n            if (accumulatedArea + stripArea >= targetArea) {\n                double missingArea = targetArea - accumulatedArea;\n                return bottomY + (missingArea / width);\n            }\n            accumulatedArea += stripArea;\n        }\n\n        return 0.0;\n    }\n\n    // Brute force union width calculation: O(K log K) where K is active squares\n    private double getUnionWidth(List<Interval> intervals) {\n        if (intervals.isEmpty()) return 0;\n\n        // Create a copy to sort, so we don't mess up the main list order unnecessarily\n        List<Interval> sorted = new ArrayList<>(intervals);\n        Collections.sort(sorted);\n\n        double unionLength = 0;\n        double currentEnd = -1e18; // Negative infinity\n\n        for (Interval iv : sorted) {\n            if (iv.start >= currentEnd) {\n                // Disjoint interval\n                unionLength += (iv.end - iv.start);\n                currentEnd = iv.end;\n            } else if (iv.end > currentEnd) {\n                // Overlapping interval\n                unionLength += (iv.end - currentEnd);\n                currentEnd = iv.end;\n            }\n        }\n        return unionLength;\n    }\n}",
        "readme": "",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": false,
      "hasNotes": false,
      "lastUpdated": "2026-01-14T17:54:29.000Z"
    },
    {
      "id": "leetcode-hard-trionic-array-ii",
      "platform": "Leetcode",
      "difficulty": "Hard",
      "problemName": "Trionic Array II",
      "language": "java",
      "files": {
        "code": "class Solution {\n\n    public long maxSumTrionic(int[] nums) {\n        \n        int n = nums.length;\n        long res= -1 * (long)1e16;\n\n        for(int i=1;i<n-2;i++){\n\n            int a = i; \n            int b = i; \n\n            long net = nums[a];\n\n            while(b+1<n && nums[b+1] < nums[b]){\n                net+=(long)nums[b+1];\n                b++;\n            }\n\n            if(b==a)continue;\n\n            int c= b; \n\n            long left = 0;\n            long right = 0;\n\n            long lx =Integer.MIN_VALUE;\n            long rx =Integer.MIN_VALUE;\n\n            while(a-1>=0 && nums[a-1] < nums[a]){\n                left+=(long)nums[a-1];\n                lx = Math.max(lx, left);\n                a--;\n            }\n\n            if(a==i)continue;\n\n            while(b+1<n && nums[b+1] > nums[b]){\n                right+=(long)nums[b+1];\n                rx = Math.max(rx, right);\n                b++;\n            }\n\n            if(b==c)continue;\n            i=b-1;\n            res = Math.max( res, lx+rx+net);\n\n        }\n        return res;\n    }\n}",
        "readme": "SeniorStaffArrayDynamicProgrammingWeeklyContest461\n\nYou are given an integer array nums of length n.\n\nA trionic subarray is a contiguous subarray nums[l...r] (with 0 <= l < r < n) for which there exist indices l < p < q < r such that:\n\n\n\tnums[l...p] is strictly increasing,\n\tnums[p...q] is strictly decreasing,\n\tnums[q...r] is strictly increasing.\n\n\nReturn the maximum sum of any trionic subarray in nums.\n\n \nExample 1:\n\n\nInput: nums = [0,-2,-1,-3,0,2,-1]\n\nOutput: -4\n\nExplanation:\n\nPick l = 1, p = 2, q = 3, r = 5:\n\n\n\tnums[l...p] = nums[1...2] = [-2, -1] is strictly increasing (-2 < -1).\n\tnums[p...q] = nums[2...3] = [-1, -3] is strictly decreasing (-1 > -3)\n\tnums[q...r] = nums[3...5] = [-3, 0, 2] is strictly increasing (-3 < 0 < 2).\n\tSum = (-2) + (-1) + (-3) + 0 + 2 = -4.\n\n\n\nExample 2:\n\n\nInput: nums = [1,4,2,7]\n\nOutput: 14\n\nExplanation:\n\nPick l = 0, p = 1, q = 2, r = 3:\n\n\n\tnums[l...p] = nums[0...1] = [1, 4] is strictly increasing (1 < 4).\n\tnums[p...q] = nums[1...2] = [4, 2] is strictly decreasing (4 > 2).\n\tnums[q...r] = nums[2...3] = [2, 7] is strictly increasing (2 < 7).\n\tSum = 1 + 4 + 2 + 7 = 14.\n\n\n\n \nConstraints:\n\n\n\t4 <= n = nums.length <= 105\n\t-109 <= nums[i] <= 109\n\tIt is guaranteed that at least one trionic subarray exists.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-02-04T03:58:33.000Z"
    }
  ]
}