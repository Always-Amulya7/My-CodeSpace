{
  "metadata": {
    "totalProblems": 26,
    "lastUpdated": "2026-01-22T14:35:39.720Z",
    "breakdown": {
      "Codechef": {
        "total": 0,
        "Easy": 0,
        "Medium": 0,
        "Hard": 0
      },
      "Gfg": {
        "total": 1,
        "Easy": 1,
        "Medium": 0,
        "Hard": 0
      },
      "Leetcode": {
        "total": 22,
        "Easy": 6,
        "Medium": 12,
        "Hard": 4
      },
      "Hackerrank": {
        "total": 3,
        "Easy": 0,
        "Medium": 3,
        "Hard": 0
      }
    }
  },
  "problems": [
    {
      "id": "gfg-easy-decision-making-in-java",
      "platform": "Gfg",
      "difficulty": "Easy",
      "problemName": "Decision Making in Java",
      "language": "java",
      "files": {
        "code": "class Solution {\n     static String compareNM(int n, int m){\n        if(n<m){\n            return \"lesser\";\n        }\n        else if(n==m){\n            return \"equal\";\n        }\n        else{\n            return \"greater\";\n        }\n        \n    }\n }",
        "readme": "Decision_Making_Javaif_Else_Switch_Break_Continue_Jump\n\nDecision Making in Java\nDifficulty: BasicAccuracy: 60.12%Submissions: 208K+Points: 1\n\nGiven two integers, nÂ and m. The task is to check the relation between n and m. Return \"lesser\" if n < m,Â  \"equal\" if n == m, and \"greater\" if n > m.\n\nExamples :\n\n\nInput: n = 4, m = 8\nOutput: lesser\nExplanation: 4 < 8 so print 'lesser'.\nInput: n = 8, m = 8\nOutput: equal\nExplanation: 8 = 8 so print 'equal'.\nInput: n = 8, m = 4\nOutput: greater\nExplanation: 8 > 4 so print 'greater'.\n\nConstraints:\n-109 <= m , n <= 109\n\n\nTry more examples\nExpected Complexities\nTopic Tags\nRelated Articles\nReport An Issue\nIf you are facing any issue on this page. Please let us know.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-12-29T08:07:30.000Z"
    },
    {
      "id": "hackerrank-medium-java-date-and-time",
      "platform": "Hackerrank",
      "difficulty": "Medium",
      "problemName": "Java Date and Time",
      "language": "java",
      "files": {
        "code": "import java.io.*;\nimport java.math.*;\nimport java.security.*;\nimport java.text.*;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.function.*;\nimport java.util.regex.*;\nimport java.util.stream.*;\nimport static java.util.stream.Collectors.joining;\nimport static java.util.stream.Collectors.toList;\n\nclass Result {\n\n    /*\n     * Complete the 'findDay' function below.\n     *\n     * The function is expected to return a STRING.\n     * The function accepts following parameters:\n     *  1. INTEGER month\n     *  2. INTEGER day\n     *  3. INTEGER year\n     */\n\n    public static String findDay(int month, int day, int year) {\n    Calendar calendar = Calendar.getInstance();\n    calendar.set(year, month - 1, day);\n    var dayOfWeek = calendar.get(calendar.DAY_OF_WEEK);\n    String[] names = new String[] {\"SUNDAY\", \"MONDAY\", \"TUESDAY\", \"WEDNESDAY\", \"THURSDAY\", \"FRIDAY\", \"SATURDAY\"};\n    return names[dayOfWeek - 1];\n}\n\n}\n\npublic class Solution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(\"OUTPUT_PATH\")));\n\n        String[] firstMultipleInput = bufferedReader.readLine().replaceAll(\"\\\\s+$\", \"\").split(\" \");\n\n        int month = Integer.parseInt(firstMultipleInput[0]);\n\n        int day = Integer.parseInt(firstMultipleInput[1]);\n\n        int year = Integer.parseInt(firstMultipleInput[2]);\n\n        String res = Result.findDay(month, day, year);\n\n        bufferedWriter.write(res);\n        bufferedWriter.newLine();\n\n        bufferedReader.close();\n        bufferedWriter.close();\n    }\n}",
        "readme": "null\n\nThe Calendar class is an abstract class that provides methods for converting between a specific instant in time and a set of calendar fields such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so on, and for manipulating the calendar fields, such as getting the date of the next week.\n\nYou are given a date. You just need to write the method, , which returns the day on that date. To simplify your task, we have provided a portion of the code in the editor.\n\nExample\n\n\n\n\nThe method should return  as the day on that date.\n\nFunction Description\n\nComplete the findDay function in the editor below.\n\nfindDay has the following parameters:\n\nint: month\nint: day\nint: year\n\nReturns\n\nstring: the day of the week in capital letters\n\nInput Format\n\nA single line of input containing the space separated month, day and year, respectively, in    format.\n\nConstraints\n\nSample Input\n\n08 05 2015\n\n\nSample Output\n\nWEDNESDAY\n\n\nExplanation\n\nThe day on August th  was WEDNESDAY.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-12-29T08:10:52.000Z"
    },
    {
      "id": "hackerrank-medium-java-int-to-string",
      "platform": "Hackerrank",
      "difficulty": "Medium",
      "problemName": "Java Int to String",
      "language": "java",
      "files": {
        "code": "import java.util.Scanner;\n\nclass Solution\n{\n    public static void main(String args[])\n    {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.close();\n        \n        String s = Integer.toString(n);\n        \n        if(n == Integer.parseInt(s))\n            System.out.println(\"Good job\");\n        else\n            System.out.println(\"Wrong Answer\");\n    }\n}",
        "readme": "",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": false,
      "hasNotes": false,
      "lastUpdated": "2025-12-29T08:09:51.000Z"
    },
    {
      "id": "hackerrank-medium-java-stdin-and-stdout-ii",
      "platform": "Hackerrank",
      "difficulty": "Medium",
      "problemName": "Java Stdin and Stdout II",
      "language": "java",
      "files": {
        "code": "import java.util.Scanner;\n\nclass Solution\n{\n    public static void main(String args[])\n    {\n        Scanner sc = new Scanner(System.in);\n        \n        int n = sc.nextInt();\n        double d = sc.nextDouble();\n        sc.nextLine();\n        String s = sc.nextLine();\n        \n        sc.close();\n        \n        System.out.println(\"String: \" + s);\n        System.out.println(\"Double: \" + d);\n        System.out.println(\"Int: \" + n);\n    }\n}",
        "readme": "null\n\nIn this challenge, you must read an integer, a double, and a String from stdin, then print the values according to the instructions in the Output Format section below. To make the problem a little easier, a portion of the code is provided for you in the editor.\n\nNote: We recommend completing Java Stdin and Stdout I before attempting this challenge.\n\nInput Format\n\nThere are three lines of input:\n\nThe first line contains an integer.\nThe second line contains a double.\nThe third line contains a String.\n\nOutput Format\n\nThere are three lines of output:\n\nOn the first line, print String: followed by the unaltered String read from stdin.\nOn the second line, print Double: followed by the unaltered double read from stdin.\nOn the third line, print Int: followed by the unaltered integer read from stdin.\n\nTo make the problem easier, a portion of the code is already provided in the editor.\n\nNote: If you use the nextLine() method immediately following the nextInt() method, recall that nextInt() reads integer tokens; because of this, the last newline character for that line of integer input is still queued in the input buffer and the next nextLine() will be reading the remainder of the integer line (which is empty).\n\nSample Input\n\n42\n3.1415\nWelcome to HackerRank's Java tutorials!\n\n\nSample Output\n\nString: Welcome to HackerRank's Java tutorials!\nDouble: 3.1415\nInt: 42",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-12-29T08:09:06.000Z"
    },
    {
      "id": "leetcode-easy-construct-the-minimum-bitwise-array-i",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Construct the Minimum Bitwise Array I",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int[] minBitwiseArray(List<Integer> nums) {\n        int ans[] = new int[nums.size()];\n        for(int i = 0; i < nums.size(); i++) {\n            int n = nums.get(i);\n            if(n != 2) ans[i] = n - ((n + 1) & (-n - 1)) / 2;\n            else ans[i] = -1;\n        }  \n        return ans;\n    }\n}",
        "readme": "ArrayBitManipulationBiweeklyContest141\n\nYou are given an array nums consisting of n prime integers.\n\nYou need to construct an array ans of length n, such that, for each index i, the bitwise OR of ans[i] and ans[i] + 1 is equal to nums[i], i.e. ans[i] OR (ans[i] + 1) == nums[i].\n\nAdditionally, you must minimize each value of ans[i] in the resulting array.\n\nIf it is not possible to find such a value for ans[i] that satisfies the condition, then set ans[i] = -1.\n\nÂ \nExample 1:\n\n\nInput: nums = [2,3,5,7]\n\nOutput: [-1,1,4,3]\n\nExplanation:\n\n\n\tFor i = 0, as there is no value for ans[0] that satisfies ans[0] OR (ans[0] + 1) = 2, so ans[0] = -1.\n\tFor i = 1, the smallest ans[1] that satisfies ans[1] OR (ans[1] + 1) = 3 is 1, because 1 OR (1 + 1) = 3.\n\tFor i = 2, the smallest ans[2] that satisfies ans[2] OR (ans[2] + 1) = 5 is 4, because 4 OR (4 + 1) = 5.\n\tFor i = 3, the smallest ans[3] that satisfies ans[3] OR (ans[3] + 1) = 7 is 3, because 3 OR (3 + 1) = 7.\n\n\n\nExample 2:\n\n\nInput: nums = [11,13,31]\n\nOutput: [9,12,15]\n\nExplanation:\n\n\n\tFor i = 0, the smallest ans[0] that satisfies ans[0] OR (ans[0] + 1) = 11 is 9, because 9 OR (9 + 1) = 11.\n\tFor i = 1, the smallest ans[1] that satisfies ans[1] OR (ans[1] + 1) = 13 is 12, because 12 OR (12 + 1) = 13.\n\tFor i = 2, the smallest ans[2] that satisfies ans[2] OR (ans[2] + 1) = 31 is 15, because 15 OR (15 + 1) = 31.\n\n\n\nÂ \nConstraints:\n\n\n\t1 <= nums.length <= 100\n\t2 <= nums[i] <= 1000\n\tnums[i] is a prime number.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-20T03:40:47.000Z"
    },
    {
      "id": "leetcode-easy-longest-common-prefix",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Longest Common Prefix",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public String longestCommonPrefix(String[] v) {\n        StringBuilder ans = new StringBuilder();\n        Arrays.sort(v);\n        String first = v[0];\n        String last = v[v.length-1];\n        for (int i=0; i<Math.min(first.length(), last.length()); i++) {\n            if (first.charAt(i) != last.charAt(i)) {\n                return ans.toString();\n            }\n            ans.append(first.charAt(i));\n        }\n        return ans.toString();\n    }\n}",
        "readme": "ArrayStringTrie\n\nWrite a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string \"\".\n\nÂ \nExample 1:\n\nInput: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"\n\n\nExample 2:\n\nInput: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings.\n\n\nÂ \nConstraints:\n\n\n\t1 <= strs.length <= 200\n\t0 <= strs[i].length <= 200\n\tstrs[i] consists of only lowercase English letters if it is non-empty.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-05T17:27:23.000Z"
    },
    {
      "id": "leetcode-easy-minimum-pair-removal-to-sort-array-i",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Minimum Pair Removal to Sort Array I",
      "language": "java",
      "files": {
        "code": "class Solution {\n    private boolean isSorted(int[] nums, int n) {\n        for(int i = 1; i < n; i++) {\n            if(nums[i] < nums[i - 1]) return false;\n        }\n        return true;\n    }\n    public int minimumPairRemoval(int[] nums) {\n        int ans = 0, n = nums.length;\n        while(!isSorted(nums, n)) {\n            ans += 1;\n            int min_sum = Integer.MAX_VALUE, pos = -1;\n            for(int i = 1; i < n; i++) {\n                int sum = nums[i - 1] + nums[i];\n                if(sum < min_sum) {\n                    min_sum = sum;\n                    pos = i;\n                }\n            }\n            nums[pos - 1] = min_sum;\n            for(int i = pos; i < n - 1; i++) nums[i] = nums[i + 1];\n            n--;\n        }\n        return ans;\n    }\n}",
        "readme": "",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": false,
      "hasNotes": false,
      "lastUpdated": "2026-01-22T14:35:25.000Z"
    },
    {
      "id": "leetcode-easy-minimum-time-visiting-all-points",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Minimum Time Visiting All Points",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int minTimeToVisitAllPoints(int[][] points) {\n        int ans = 0;\n        for (int i = 0; i < points.length - 1; i++) {\n            int currX = points[i][0];\n            int currY = points[i][1];\n            int targetX = points[i + 1][0];\n            int targetY = points[i + 1][1];\n            ans += Math.max(Math.abs(targetX - currX), Math.abs(targetY - currY));\n        }\n        \n        return ans;\n    }\n}",
        "readme": "",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": false,
      "hasNotes": false,
      "lastUpdated": "2026-01-12T07:43:19.000Z"
    },
    {
      "id": "leetcode-easy-n-repeated-element-in-size-2n-array",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "N-Repeated Element in Size 2N Array",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int repeatedNTimes(int[] nums) {\n        int n = nums.length - 1;\n        if(nums[0] == nums[n]) return nums[0];\n        for(int i = 0; i < n; i++) {\n            if(nums[i] == nums[i + 1] || nums[i] == nums[i + 2]) return nums[i];\n        }\n        return nums[0];\n    }\n}",
        "readme": "",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": false,
      "hasNotes": false,
      "lastUpdated": "2026-01-02T12:14:05.000Z"
    },
    {
      "id": "leetcode-easy-plus-one",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Plus One",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int[] plusOne(int[] digits) {\n        for (int i = digits.length - 1; i >= 0; i--) {\n            if (digits[i] < 9) {\n                digits[i]++;\n                return digits;\n            }\n            digits[i] = 0;\n        }\n        int[] result = new int[digits.length + 1];\n        result[0] = 1;\n        return result;\n    }\n}",
        "readme": "DailyCodingChallengeCompleted!,CompletionStreak:,169,Days,Consistencyiskey,seeyoutomorrow!\n\nYou are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\n\nIncrement the large integer by one and return the resulting array of digits.\n\nÂ \nExample 1:\n\nInput: digits = [1,2,3]\nOutput: [1,2,4]\nExplanation: The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be [1,2,4].\n\n\nExample 2:\n\nInput: digits = [4,3,2,1]\nOutput: [4,3,2,2]\nExplanation: The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be [4,3,2,2].\n\n\nExample 3:\n\nInput: digits = [9]\nOutput: [1,0]\nExplanation: The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be [1,0].\n\n\nÂ \nConstraints:\n\n\n\t1 <= digits.length <= 100\n\t0 <= digits[i] <= 9\n\tdigits does not contain any leading 0's.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-01T09:43:58.000Z"
    },
    {
      "id": "leetcode-medium-construct-the-minimum-bitwise-array-ii",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Construct the Minimum Bitwise Array II",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int[] minBitwiseArray(List<Integer> nums) {\n        int ans[] = new int[nums.size()];\n        for(int i = 0; i < nums.size(); i++) {\n            int n = nums.get(i);\n            if(n != 2) ans[i] = n - ((n + 1) & (-n - 1)) / 2;\n            else ans[i] = -1;\n        }  \n        return ans;\n    }\n}",
        "readme": "ArrayBitManipulationBiweeklyContest141\n\nYou are given an array nums consisting of n prime integers.\n\nYou need to construct an array ans of length n, such that, for each index i, the bitwise OR of ans[i] and ans[i] + 1 is equal to nums[i], i.e. ans[i] OR (ans[i] + 1) == nums[i].\n\nAdditionally, you must minimize each value of ans[i] in the resulting array.\n\nIf it is not possible to find such a value for ans[i] that satisfies the condition, then set ans[i] = -1.\n\nÂ \nExample 1:\n\n\nInput: nums = [2,3,5,7]\n\nOutput: [-1,1,4,3]\n\nExplanation:\n\n\n\tFor i = 0, as there is no value for ans[0] that satisfies ans[0] OR (ans[0] + 1) = 2, so ans[0] = -1.\n\tFor i = 1, the smallest ans[1] that satisfies ans[1] OR (ans[1] + 1) = 3 is 1, because 1 OR (1 + 1) = 3.\n\tFor i = 2, the smallest ans[2] that satisfies ans[2] OR (ans[2] + 1) = 5 is 4, because 4 OR (4 + 1) = 5.\n\tFor i = 3, the smallest ans[3] that satisfies ans[3] OR (ans[3] + 1) = 7 is 3, because 3 OR (3 + 1) = 7.\n\n\n\nExample 2:\n\n\nInput: nums = [11,13,31]\n\nOutput: [9,12,15]\n\nExplanation:\n\n\n\tFor i = 0, the smallest ans[0] that satisfies ans[0] OR (ans[0] + 1) = 11 is 9, because 9 OR (9 + 1) = 11.\n\tFor i = 1, the smallest ans[1] that satisfies ans[1] OR (ans[1] + 1) = 13 is 12, because 12 OR (12 + 1) = 13.\n\tFor i = 2, the smallest ans[2] that satisfies ans[2] OR (ans[2] + 1) = 31 is 15, because 15 OR (15 + 1) = 31.\n\n\n\nÂ \nConstraints:\n\n\n\t1 <= nums.length <= 100\n\t2 <= nums[i] <= 109\n\tnums[i] is a prime number.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-21T03:31:48.000Z"
    },
    {
      "id": "leetcode-medium-find-the-largest-area-of-square-inside-two-rectangles",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Find the Largest Area of Square Inside Two Rectangles",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public long largestSquareArea(int[][] bottomLeft, int[][] topRight) {\n        long maxSide = 0;\n        int n = bottomLeft.length;\n\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Find intersection boundaries\n                // Use Math.max for lower bounds (left, bottom)\n                // Use Math.min for upper bounds (right, top)\n                int x1 = Math.max(bottomLeft[i][0], bottomLeft[j][0]);\n                int y1 = Math.max(bottomLeft[i][1], bottomLeft[j][1]);\n                int x2 = Math.min(topRight[i][0], topRight[j][0]);\n                int y2 = Math.min(topRight[i][1], topRight[j][1]);\n\n                // Width and Height of the intersection rectangle\n                long width = x2 - x1;\n                long height = y2 - y1;\n\n                // If valid intersection (width and height > 0)\n                if (width > 0 && height > 0) {\n                    long side = Math.min(width, height);\n                    maxSide = Math.max(maxSide, side);\n                }\n            }\n        }\n\n        return maxSide * maxSide;\n    }\n}",
        "readme": "ArrayMathGeometryWeeklyContest386\n\nThere exist n rectangles in a 2D plane with edges parallel to the x and y axis. You are given two 2D integer arraysÂ bottomLeft and topRightÂ where bottomLeft[i] = [a_i, b_i] and topRight[i] = [c_i, d_i] representÂ the bottom-left and top-right coordinates of the ith rectangle, respectively.\n\nYou need to find the maximum area of a square that can fit inside the intersecting region of at least two rectangles. Return 0 if such a square does not exist.\n\nÂ \nExample 1:\n\nInput: bottomLeft = [[1,1],[2,2],[3,1]], topRight = [[3,3],[4,4],[6,6]]\n\nOutput: 1\n\nExplanation:\n\nA square with side length 1 can fit inside either the intersecting region of rectangles 0 and 1 or the intersecting region of rectangles 1 and 2. Hence the maximum area is 1. It can be shown that a square with a greater side length can not fit inside any intersecting region of two rectangles.\n\nExample 2:\n\nInput: bottomLeft = [[1,1],[1,3],[1,5]], topRight = [[5,5],[5,7],[5,9]]\n\nOutput: 4\n\nExplanation:\n\nA square with side length 2 can fit inside either the intersecting region of rectangles 0 and 1 or the intersecting region of rectangles 1 and 2. Hence the maximum area is 2 * 2 = 4. It can be shown that a square with a greater side length can not fit inside any intersecting region of two rectangles.\n\nExample 3:\n  \n\nInput: bottomLeft = [[1,1],[2,2],[1,2]], topRight = [[3,3],[4,4],[3,4]]\n\nOutput: 1\n\nExplanation:\n\nA square with side length 1 can fit inside the intersecting region of any two rectangles. Also, no larger square can, so the maximum area is 1. Note that the region can be formed by the intersection of more than 2 rectangles.\n\nExample 4:\n  \n\nInput:Â bottomLeft = [[1,1],[3,3],[3,1]], topRight = [[2,2],[4,4],[4,2]]\n\nOutput: 0\n\nExplanation:\n\nNo pair of rectangles intersect, hence, the answer is 0.\n\nÂ \nConstraints:\n\n\n\tn == bottomLeft.length == topRight.length\n\t2 <= n <= 103\n\tbottomLeft[i].length == topRight[i].length == 2\n\t1 <= bottomLeft[i][0], bottomLeft[i][1] <= 107\n\t1 <= topRight[i][0], topRight[i][1] <= 107\n\tbottomLeft[i][0] < topRight[i][0]\n\tbottomLeft[i][1] < topRight[i][1]",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-17T11:05:34.000Z"
    },
    {
      "id": "leetcode-medium-four-divisors",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Four Divisors",
      "language": "java",
      "files": {
        "code": "class Solution {\n    private int factors(int n) {\n        int sum = 0, c = 0;\n        for(int i = 2; i*i <= n; i++) {\n            if(n % i == 0) {\n                int j = n / i;\n                if(j == i || c > 0) return 0;\n                sum += i + j;\n                c++;\n            }\n        }\n        if(c == 0) return 0;\n        return 1 + sum + n;\n    }\n    public int sumFourDivisors(int[] nums) {\n        int sum = 0;\n        for(int i = 0; i < nums.length; i++) {\n            sum += factors(nums[i]);\n        }\n        return sum;\n    }\n}",
        "readme": "DailyCodingChallengeCompleted!,CompletionStreak:,172,Days,Consistencyiskey,seeyoutomorrow!\n\nGiven an integer array nums, return the sum of divisors of the integers in that array that have exactly four divisors. If there is no such integer in the array, return 0.\n\nÂ \nExample 1:\n\nInput: nums = [21,4,7]\nOutput: 32\nExplanation: \n21 has 4 divisors: 1, 3, 7, 21\n4 has 3 divisors: 1, 2, 4\n7 has 2 divisors: 1, 7\nThe answer is the sum of divisors of 21 only.\n\n\nExample 2:\n\nInput: nums = [21,21]\nOutput: 64\n\n\nExample 3:\n\nInput: nums = [1,2,3,4,5]\nOutput: 0\n\n\nÂ \nConstraints:\n\n\n\t1 <= nums.length <= 104\n\t1 <= nums[i] <= 105",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-04T13:45:09.000Z"
    },
    {
      "id": "leetcode-medium-integer-to-roman",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Integer to Roman",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public static void main(String[] args) {}\n\n    public String intToRoman(int num) {\n        String[][] s = {\n            {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"},\n            {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"},\n            {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"},\n            {\"\", \"M\", \"MM\", \"MMM\"}\n        };\n\n        return s[3][num / 1000 % 10] + s[2][num / 100 % 10] + s[1][num / 10 % 10] + s[0][num % 10];\n    }\n}",
        "readme": "HashTableMathString\n\nSeven different symbols represent Roman numerals with the following values:\n\nSymbolValueI1V5X10L50C100D500M1000\n\nRoman numerals are formed by appendingÂ the conversions ofÂ decimal place valuesÂ from highest to lowest. Converting a decimal place value into a Roman numeral has the following rules:\n\n\n\tIf the value does not start with 4 orÂ 9, select the symbol of the maximal value that can be subtracted from the input, append that symbol to the result, subtract its value, and convert the remainder to a Roman numeral.\n\tIf the value starts with 4 or 9 use theÂ subtractive formÂ representingÂ one symbol subtracted from the following symbol, for example,Â 4 is 1 (I) less than 5 (V): IVÂ and 9 is 1 (I) less than 10 (X): IX.Â Only the following subtractive forms are used: 4 (IV), 9 (IX),Â 40 (XL), 90 (XC), 400 (CD) and 900 (CM).\n\tOnly powers of 10 (I, X, C, M) can be appended consecutively at most 3 times to represent multiples of 10. You cannot append 5Â (V), 50 (L), or 500 (D) multiple times. If you need to append a symbolÂ 4 timesÂ use the subtractive form.\n\n\nGiven an integer, convert it to a Roman numeral.\n\nÂ \nExample 1:\n\n\nInput: num = 3749\n\nOutput: \"MMMDCCXLIX\"\n\nExplanation:\n\n3000 = MMM as 1000 (M) + 1000 (M) + 1000 (M)\n 700 = DCC as 500 (D) + 100 (C) + 100 (C)\n  40 = XL as 10 (X) less of 50 (L)\n   9 = IX as 1 (I) less of 10 (X)\nNote: 49 is not 1 (I) less of 50 (L) because the conversion is based on decimal places\n\n\n\nExample 2:\n\n\nInput: num = 58\n\nOutput: \"LVIII\"\n\nExplanation:\n\n50 = L\n 8 = VIII\n\n\n\nExample 3:\n\n\nInput: num = 1994\n\nOutput: \"MCMXCIV\"\n\nExplanation:\n\n1000 = M\n 900 = CM\n  90 = XC\n   4 = IV\n\n\n\nÂ \nConstraints:\n\n\n\t1 <= num <= 3999",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-12-29T07:54:23.000Z"
    },
    {
      "id": "leetcode-medium-largest-magic-square",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Largest Magic Square",
      "language": "java",
      "files": {
        "code": "class Solution {\n\n    public int largestMagicSquare(int[][] mat) {\n        int R = mat.length;\n        int C = mat[0].length;\n\n        // Row prefix sums\n        int[][] rowSum = new int[R][C];\n        for (int r = 0; r < R; r++) {\n            rowSum[r][0] = mat[r][0];\n            for (int c = 1; c < C; c++) {\n                rowSum[r][c] = rowSum[r][c - 1] + mat[r][c];\n            }\n        }\n\n        // Column prefix sums\n        int[][] colSum = new int[R][C];\n        for (int c = 0; c < C; c++) {\n            colSum[0][c] = mat[0][c];\n            for (int r = 1; r < R; r++) {\n                colSum[r][c] = colSum[r - 1][c] + mat[r][c];\n            }\n        }\n\n        int maxSize = 1;\n\n        // Try every cell as top-left\n        for (int r = 0; r < R; r++) {\n            for (int c = 0; c < C; c++) {\n                int maxPossible = Math.min(R - r, C - c);\n\n                // Try bigger squares first\n                for (int size = maxPossible; size > maxSize; size--) {\n                    if (isMagic(r, c, size, mat, rowSum, colSum)) {\n                        maxSize = size;\n                        break;\n                    }\n                }\n            }\n        }\n        return maxSize;\n    }\n\n    private boolean isMagic(\n            int sr, int sc, int size,\n            int[][] mat, int[][] rowSum, int[][] colSum) {\n\n        // Target sum from first row\n        int target = rowSum[sr][sc + size - 1]\n                   - (sc > 0 ? rowSum[sr][sc - 1] : 0);\n\n        // Check rows\n        for (int r = sr; r < sr + size; r++) {\n            int sum = rowSum[r][sc + size - 1]\n                    - (sc > 0 ? rowSum[r][sc - 1] : 0);\n            if (sum != target) return false;\n        }\n\n        // Check columns\n        for (int c = sc; c < sc + size; c++) {\n            int sum = colSum[sr + size - 1][c]\n                    - (sr > 0 ? colSum[sr - 1][c] : 0);\n            if (sum != target) return false;\n        }\n\n        // Main diagonal\n        int d1 = 0;\n        for (int k = 0; k < size; k++)\n            d1 += mat[sr + k][sc + k];\n        if (d1 != target) return false;\n\n        // Anti-diagonal\n        int d2 = 0;\n        for (int k = 0; k < size; k++)\n            d2 += mat[sr + size - 1 - k][sc + k];\n\n        return d2 == target;\n    }\n}",
        "readme": "DailyCodingChallengeCompleted!,CompletionStreak:,186,Days,Consistencyiskey,seeyoutomorrow!\n\nA k x k magic square is a k x k grid filled with integers such that every row sum, every column sum, and both diagonal sums are all equal. The integers in the magic square do not have to be distinct. Every 1 x 1 grid is trivially a magic square.\n\nGiven an m x n integer grid, return the size (i.e., the side length k) of the largest magic square that can be found within this grid.\n\nÂ \nExample 1:\n\nInput: grid = [[7,1,4,5,6],[2,5,1,6,4],[1,5,4,3,2],[1,2,7,3,4]]\nOutput: 3\nExplanation: The largest magic square has a size of 3.\nEvery row sum, column sum, and diagonal sum of this magic square is equal to 12.\n- Row sums: 5+1+6 = 5+4+3 = 2+7+3 = 12\n- Column sums: 5+5+2 = 1+4+7 = 6+3+3 = 12\n- Diagonal sums: 5+4+3 = 6+4+2 = 12\n\n\nExample 2:\n\nInput: grid = [[5,1,3,1],[9,3,3,1],[1,3,3,8]]\nOutput: 2\n\n\nÂ \nConstraints:\n\n\n\tm == grid.length\n\tn == grid[i].length\n\t1 <= m, n <= 50\n\t1 <= grid[i][j] <= 106",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-18T03:41:28.000Z"
    },
    {
      "id": "leetcode-medium-magic-squares-in-grid",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Magic Squares In Grid",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public boolean isMagicSquare(int[][] grid, int r, int c) {\n        if (grid[r+1][c+1] != 5) return false; //center must always be 5\n\n        int a = grid[r][c],b = grid[r][c+1],d = grid[r][c+2]; // grid ele except centre\n        int e = grid[r+1][c],f = grid[r+1][c+2];\n        int h = grid[r+2][c],i = grid[r+2][c+1],j = grid[r+2][c+2];\n\n        boolean[] seen = new boolean[10];\n        int[] arr = {a,b,d,e,f,h,i,j,5};// 1 - 9 checking\n        for (int x : arr) {\n            if (x < 1 || x > 9 || seen[x]) return false;\n            seen[x] = true;\n        }\n\n        if (a + j != 10) return false; //opposite cells must sum to 10\n        if (b + i != 10) return false;\n        if (d + h != 10) return false;\n        if (e + f != 10) return false;\n\n         // Check all rows, columns, and diagonals sum to 15\n        if (a + b + d != 15) return false;\n        if (h + i + j != 15) return false;\n        if (a + e + h != 15) return false;\n        if (d + f + j != 15) return false;\n        if (a + 5 + j != 15) return false;// centre is 5\n        if (d + 5 + h != 15) return false;\n\n        return true;\n    }\n\n    public int numMagicSquaresInside(int[][] grid) {\n        int m = grid.length, n = grid[0].length, c = 0;\n        for (int i = 0;i <= m-3;i++) {\n            for (int j = 0;j <= n-3;j++) {\n                if (isMagicSquare(grid,i,j)) c++;\n            }\n        }\n        return c;\n    }\n}",
        "readme": "DailyCodingChallengeCompleted!,CompletionStreak:,167,Days,Consistencyiskey,seeyoutomorrow!\n\nA 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum.\n\nGiven a row x col grid of integers, how many 3 x 3 magic square subgrids are there?\n\nNote: while a magic square can only contain numbers from 1 to 9, grid may contain numbers up to 15.\n\nÂ \nExample 1:\n\nInput: grid = [[4,3,8,4],[9,5,1,9],[2,7,6,2]]\nOutput: 1\nExplanation: \nThe following subgrid is a 3 x 3 magic square:\n\nwhile this one is not:\n\nIn total, there is only one magic square inside the given grid.\n\n\nExample 2:\n\nInput: grid = [[8]]\nOutput: 0\n\n\nÂ \nConstraints:\n\n\n\trow == grid.length\n\tcol == grid[i].length\n\t1 <= row, col <= 10\n\t0 <= grid[i][j] <= 15",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-12-30T15:11:28.000Z"
    },
    {
      "id": "leetcode-medium-maximize-area-of-square-hole-in-grid",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Maximize Area of Square Hole in Grid",
      "language": "java",
      "files": {
        "code": "class Solution {\n    private int maxLen(int[] Bars) {\n        int count = 2, length = 2;\n        for(int i = 1; i < Bars.length; i++) {\n            if(Bars[i] - Bars[i-1] == 1) count++;\n            else count = 2;\n            length = Math.max(length, count);\n        }\n        return length;\n    }\n    public int maximizeSquareHoleArea(int n, int m, int[] hBars, int[] vBars) {\n        Arrays.sort(hBars);\n        Arrays.sort(vBars);\n        int side = Math.min(maxLen(hBars), maxLen(vBars));\n        return side * side; \n    }\n}",
        "readme": "ArraySortingBiweeklyContest118\n\nYou are given the two integers, n and m and two integer arrays, hBars and vBars. The grid has n + 2 horizontal and m + 2 vertical bars, creating 1 x 1 unit cells. The bars are indexed starting from 1.\n\nYou can remove some of the bars in hBars from horizontal bars and some of the bars in vBars from vertical bars. Note that other bars are fixed and cannot be removed.\n\nReturn an integer denoting the maximum area of a square-shaped hole in the grid, after removing some bars (possibly none).\n\nÂ \nExample 1:\n\n\n\n\nInput: n = 2, m = 1, hBars = [2,3], vBars = [2]\n\nOutput: 4\n\nExplanation:\n\nThe left image shows the initial grid formed by the bars. The horizontal bars are [1,2,3,4], and the vertical bars areÂ [1,2,3].\n\nOne way to get the maximum square-shaped hole is by removing horizontal bar 2 and vertical bar 2.\n\n\nExample 2:\n\n\n\n\nInput: n = 1, m = 1, hBars = [2], vBars = [2]\n\nOutput: 4\n\nExplanation:\n\nTo get the maximum square-shaped hole, we remove horizontal bar 2 and vertical bar 2.\n\n\nExample 3:\n\n\n\n\nInput: n = 2, m = 3, hBars = [2,3], vBars = [2,4]\n\nOutput: 4\n\nExplanation:\n\nOne way to get the maximum square-shaped hole is by removing horizontal bar 3, and vertical bar 4.\n\n\nÂ \nConstraints:\n\n\n\t1 <= n <= 109\n\t1 <= m <= 109\n\t1 <= hBars.length <= 100\n\t2 <= hBars[i] <= n + 1\n\t1 <= vBars.length <= 100\n\t2 <= vBars[i] <= m + 1\n\tAll values in hBars are distinct.\n\tAll values in vBars are distinct.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-15T13:30:58.000Z"
    },
    {
      "id": "leetcode-medium-maximum-matrix-sum",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Maximum Matrix Sum",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public long maxMatrixSum(int[][] matrix) {\n        long sum = 0 ;\n\n        int n = matrix.length ;\n\n        int min = 100001 ;\n\n        int negCount = 0 ;\n\n        for (int[] row : matrix)\n        {\n            for (int val : row)\n            {\n                if (val < 0)\n                {\n                    negCount++ ;\n                    val = -val ;\n                }\n\n                if (val < min) min = val ;\n\n                sum += val ;\n            }\n        }\n\n        return negCount % 2 == 0 ? sum : sum - 2L * min ;\n    }\n}",
        "readme": "DailyCodingChallengeCompleted!,CompletionStreak:,173,Days,Consistencyiskey,seeyoutomorrow!\n\nYou are given an n x n integer matrix. You can do the following operation any number of times:\n\n\n\tChoose any two adjacent elements of matrix and multiply each of them by -1.\n\n\nTwo elements are considered adjacent if and only if they share a border.\n\nYour goal is to maximize the summation of the matrix's elements. Return the maximum sum of the matrix's elements using the operation mentioned above.\n\nÂ \nExample 1:\n\nInput: matrix = [[1,-1],[-1,1]]\nOutput: 4\nExplanation: We can follow the following steps to reach sum equals 4:\n- Multiply the 2 elements in the first row by -1.\n- Multiply the 2 elements in the first column by -1.\n\n\nExample 2:\n\nInput: matrix = [[1,2,3],[-1,-2,-3],[1,2,3]]\nOutput: 16\nExplanation: We can follow the following step to reach sum equals 16:\n- Multiply the 2 last elements in the second row by -1.\n\n\nÂ \nConstraints:\n\n\n\tn == matrix.length == matrix[i].length\n\t2 <= n <= 250\n\t-105 <= matrix[i][j] <= 105",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-05T11:39:42.000Z"
    },
    {
      "id": "leetcode-medium-maximum-product-of-splitted-binary-tree",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Maximum Product of Splitted Binary Tree",
      "language": "java",
      "files": {
        "code": "class Solution {\n    static final int MOD = 1_000_000_007;\n    long totalSum = 0;\n    long maxProduct = 0;\n\n    // First DFS: compute total tree sum\n    long getTotalSum(TreeNode root) {\n        if (root == null) return 0;\n        return root.val \n             + getTotalSum(root.left) \n             + getTotalSum(root.right);\n    }\n\n    // Second DFS (postorder): compute subtree sums\n    long dfs(TreeNode root) {\n        if (root == null) return 0;\n\n        // Get sums of left and right subtrees\n        long left = dfs(root.left);\n        long right = dfs(root.right);\n\n        // Current subtree sum\n        long subSum = root.val + left + right;\n\n        // Try splitting above this node\n        long product = subSum * (totalSum - subSum);\n        maxProduct = Math.max(maxProduct, product);\n\n        return subSum;\n    }\n\n    public int maxProduct(TreeNode root) {\n        totalSum = getTotalSum(root); // O(n)\n        dfs(root);                    // O(n)\n        return (int)(maxProduct % MOD);\n    }\n}",
        "readme": "ðŸ—“ï¸Make-upnotice,ThisistheDailyCodingChallengeforJanuary7th2026.Thereare2incompletechallengesforJanuary2026andyouhave1ticketleftforthismonth.Areyousureyouwanttouseatickettomakeupthissubmission?,No,Yes\n\nGiven the root of a binary tree, split the binary tree into two subtrees by removing one edge such that the product of the sums of the subtrees is maximized.\n\nReturn the maximum product of the sums of the two subtrees. Since the answer may be too large, return it modulo 109 + 7.\n\nNote that you need to maximize the answer before taking the mod and not after taking it.\n\nÂ \nExample 1:\n\nInput: root = [1,2,3,4,5,6]\nOutput: 110\nExplanation: Remove the red edge and get 2 binary trees with sum 11 and 10. Their product is 110 (11*10)\n\n\nExample 2:\n\nInput: root = [1,null,2,3,4,null,null,5,6]\nOutput: 90\nExplanation: Remove the red edge and get 2 binary trees with sum 15 and 6.Their product is 90 (15*6)\n\n\nÂ \nConstraints:\n\n\n\tThe number of nodes in the tree is in the range [2, 5 * 104].\n\t1 <= Node.val <= 104",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-08T05:37:48.000Z"
    },
    {
      "id": "leetcode-medium-maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Maximum Side Length of a Square with Sum Less than or Equal to Threshold",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int maxSideLength(int[][] mat, int threshold) {\n        int m = mat.length, n = mat[0].length;\n        int maxSide = Math.min(m,n);\n\n        int[][] pref = new int[m+1][n+1];\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                pref[i][j] =\n                    mat[i-1][j-1]\n                  + pref[i-1][j]\n                  + pref[i][j-1]\n                  - pref[i-1][j-1];\n            }\n        }\n\n        while (maxSide > 0) {\n            for (int i = 0; i + maxSide <= m; i++) {\n                for (int j = 0; j + maxSide <= n; j++) {\n                    if (helper(pref, threshold, i, j, maxSide))\n                        return maxSide;\n                }\n            }\n            maxSide--;\n        }\n\n        return 0;\n    }\n\n    private boolean helper(int[][] pref, int t, int x, int y, int side) {\n        int x2 = x + side;\n        int y2 = y + side;\n\n        int sum =\n            pref[x2][y2]\n        - pref[x][y2]\n        - pref[x2][y]\n        + pref[x][y];\n\n        return sum <= t;\n    }\n\n}",
        "readme": "ArrayBinarySearchMatrixPrefixSumWeeklyContest167\n\nGiven a m x n matrix mat and an integer threshold, return the maximum side-length of a square with a sum less than or equal to threshold or return 0 if there is no such square.\n\nÂ \nExample 1:\n\nInput: mat = [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]], threshold = 4\nOutput: 2\nExplanation: The maximum side length of square with sum less than 4 is 2 as shown.\n\n\nExample 2:\n\nInput: mat = [[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2]], threshold = 1\nOutput: 0\n\n\nÂ \nConstraints:\n\n\n\tm == mat.length\n\tn == mat[i].length\n\t1 <= m, n <= 300\n\t0 <= mat[i][j] <= 104\n\t0 <= threshold <= 105",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-20T03:39:58.000Z"
    },
    {
      "id": "leetcode-medium-maximum-square-area-by-removing-fences-from-a-field",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Maximum Square Area by Removing Fences From a Field",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int maximizeSquareArea(int m, int n, int[] hFences, int[] vFences) {\n        // 1. Add implicit boundary fences to new lists\n        // We use Arrays to facilitate sorting and resizing\n        int[] h = Arrays.copyOf(hFences, hFences.length + 2);\n        h[hFences.length] = 1;\n        h[hFences.length + 1] = m;\n        \n        int[] v = Arrays.copyOf(vFences, vFences.length + 2);\n        v[vFences.length] = 1;\n        v[vFences.length + 1] = n;\n\n        // 2. Sort arrays\n        Arrays.sort(h);\n        Arrays.sort(v);\n\n        // 3. Store all possible horizontal gaps\n        Set<Integer> hGaps = new HashSet<>();\n        for (int i = 0; i < h.length; i++) {\n            for (int j = i + 1; j < h.length; j++) {\n                hGaps.add(h[j] - h[i]);\n            }\n        }\n\n        // 4. Check vertical gaps\n        long maxSide = -1;\n        for (int i = 0; i < v.length; i++) {\n            for (int j = i + 1; j < v.length; j++) {\n                int currentGap = v[j] - v[i];\n                if (hGaps.contains(currentGap)) {\n                    maxSide = Math.max(maxSide, currentGap);\n                }\n            }\n        }\n\n        if (maxSide == -1) return -1;\n\n        // 5. Return result modulo 10^9 + 7\n        long MOD = 1_000_000_007;\n        return (int) ((maxSide * maxSide) % MOD);\n    }\n}",
        "readme": "DailyCodingChallengeCompleted!,CompletionStreak:,184,Days,Consistencyiskey,seeyoutomorrow!\n\nThere is a large (m - 1) x (n - 1) rectangular field with corners at (1, 1) and (m, n) containing some horizontal and vertical fences given in arrays hFences and vFences respectively.\n\nHorizontal fences are from the coordinates (hFences[i], 1) to (hFences[i], n) and vertical fences are from the coordinates (1, vFences[i]) to (m, vFences[i]).\n\nReturn the maximum area of a square field that can be formed by removing some fences (possibly none) or -1 if it is impossible to make a square field.\n\nSince the answer may be large, return it modulo 109 + 7.\n\nNote: The field is surrounded by two horizontal fences from the coordinates (1, 1) to (1, n) and (m, 1) to (m, n) and two vertical fences from the coordinates (1, 1) to (m, 1) and (1, n) to (m, n). These fences cannot be removed.\n\nÂ \nExample 1:\n\n\n\nInput: m = 4, n = 3, hFences = [2,3], vFences = [2]\nOutput: 4\nExplanation: Removing the horizontal fence at 2 and the vertical fence at 2 will give a square field of area 4.\n\n\nExample 2:\n\n\n\nInput: m = 6, n = 7, hFences = [2], vFences = [4]\nOutput: -1\nExplanation: It can be proved that there is no way to create a square field by removing fences.\n\n\nÂ \nConstraints:\n\n\n\t3 <= m, n <= 109\n\t1 <= hFences.length, vFences.length <= 600\n\t1 < hFences[i] < m\n\t1 < vFences[i] < n\n\thFences and vFences are unique.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-16T16:33:37.000Z"
    },
    {
      "id": "leetcode-medium-separate-squares-i",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Separate Squares I",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public double separateSquares(int[][] squares) {\n        List<double[]> events = new ArrayList<>(); \n\n        for (int[] sq : squares) {\n            int yi = sq[1], li = sq[2];\n\n            events.add(new double[]{yi, li});\n            events.add(new double[]{yi + li, -li});\n        }\n\n        events.sort((a, b) -> Double.compare(a[0], b[0]));\n\n        double total_w = 0.0;\n        for (int[] sq : squares) {\n            int li = sq[2];\n            total_w += (double)li * li;\n        }\n\n        double target = total_w / 2.0;\n\n        double curr_y = events.get(0)[0], curr_w = 0.0, accumulated = 0.0;\n\n        for (int i = 0; i < events.size(); i++) {\n            double[] event = events.get(i);\n            double y = event[0], change = event[1];\n\n            double separate = y - curr_y;\n            accumulated += curr_w * separate;\n            \n            if (accumulated >= target) {\n                double prev = accumulated - curr_w * separate;\n\n                double need = target - prev;\n                return curr_y + need / curr_w;\n            }\n\n            curr_y = y;\n            curr_w += change;\n        }\n\n        return 0.0;\n    }\n}",
        "readme": "",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": false,
      "hasNotes": false,
      "lastUpdated": "2026-01-13T15:45:50.000Z"
    },
    {
      "id": "leetcode-hard-last-day-where-you-can-still-cross",
      "platform": "Leetcode",
      "difficulty": "Hard",
      "problemName": "Last Day Where You Can Still Cross",
      "language": "java",
      "files": {
        "code": "class Solution {\n    private int[][] directions = {{1,0},{-1,0},{0,1},{0,-1}};\n    private int rows, cols;\n    public int latestDayToCross(int row, int col, int[][] cells) {\n        this.rows = row;\n        this.cols = col;\n        int left = 1, right = cells.length, answer = 0;\n        while (left<=right){\n            int mid=left+(right-left)/2;\n            if(canCross(mid,cells)){\n                answer=mid;\n                left=mid+1;\n            } else{\n                right=mid-1;\n            }\n        }\n        return answer;\n    }\n    \n    private boolean canCross(int day, int[][] cells) {\n        int[][] grid = new int[rows][cols];\n        \n        for (int i = 0; i < day; i++) {\n            grid[cells[i][0] - 1][cells[i][1] - 1] = 1;\n        }\n        \n        Queue<int[]> queue = new LinkedList<>();\n        boolean[][] visited = new boolean[rows][cols];\n        \n        for (int c = 0; c < cols; c++) {\n            if (grid[0][c] == 0) {\n                queue.offer(new int[]{0, c});\n                visited[0][c] = true;\n            }\n        }\n        \n        while (!queue.isEmpty()) {\n            int[] curr = queue.poll();\n            int r = curr[0], c = curr[1];\n            \n            if (r == rows - 1) return true;\n            \n            for (int[] dir : directions) {\n                int nr = r + dir[0];\n                int nc = c + dir[1];\n                \n                if (nr>=0&&nr<rows&&nc>=0&&nc<cols&&!visited[nr][nc]&&grid[nr][nc]==0){\n                    visited[nr][nc]=true;\n                    queue.offer(new int[]{nr,nc});\n                }\n            }\n        }\n        return false;\n    }\n}",
        "readme": "DailyCodingChallengeCompleted!,YouhavebeenawardedDCCDecember2025!,Consistencyiskey,seeyounextmonth!\n\nThere is a 1-based binary matrix where 0 represents land and 1 represents water. You are given integers row and col representing the number of rows and columns in the matrix, respectively.\n\nInitially on day 0, the entire matrix is land. However, each day a new cell becomes flooded with water. You are given a 1-based 2D array cells, where cells[i] = [ri, ci] represents that on the ith day, the cell on the rith row and cith column (1-based coordinates) will be covered with water (i.e., changed to 1).\n\nYou want to find the last day that it is possible to walk from the top to the bottom by only walking on land cells. You can start from any cell in the top row and end at any cell in the bottom row. You can only travel in the four cardinal directions (left, right, up, and down).\n\nReturn the last day where it is possible to walk from the top to the bottom by only walking on land cells.\n\nÂ \nExample 1:\n\nInput: row = 2, col = 2, cells = [[1,1],[2,1],[1,2],[2,2]]\nOutput: 2\nExplanation: The above image depicts how the matrix changes each day starting from day 0.\nThe last day where it is possible to cross from top to bottom is on day 2.\n\n\nExample 2:\n\nInput: row = 2, col = 2, cells = [[1,1],[1,2],[2,1],[2,2]]\nOutput: 1\nExplanation: The above image depicts how the matrix changes each day starting from day 0.\nThe last day where it is possible to cross from top to bottom is on day 1.\n\n\nExample 3:\n\nInput: row = 3, col = 3, cells = [[1,2],[2,1],[3,3],[2,2],[1,1],[1,3],[2,3],[3,2],[3,1]]\nOutput: 3\nExplanation: The above image depicts how the matrix changes each day starting from day 0.\nThe last day where it is possible to cross from top to bottom is on day 3.\n\n\nÂ \nConstraints:\n\n\n\t2 <= row, col <= 2 * 104\n\t4 <= row * col <= 2 * 104\n\tcells.length == row * col\n\t1 <= ri <= row\n\t1 <= ci <= col\n\tAll the values of cells are unique.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-12-31T14:04:33.000Z"
    },
    {
      "id": "leetcode-hard-max-dot-product-of-two-subsequences",
      "platform": "Leetcode",
      "difficulty": "Hard",
      "problemName": "Max Dot Product of Two Subsequences",
      "language": "java",
      "files": {
        "code": "class Solution {\n\n    // dp[i][j] stores the maximum dot product for nums1[0..i] and nums2[0..j]\n    Integer[][] dp;\n\n    public int maxDotProduct(int[] nums1, int[] nums2) {\n        dp = new Integer[nums1.length][nums2.length];\n        return solve(nums1, nums2, nums1.length - 1, nums2.length - 1);\n    }\n\n    private int solve(int[] nums1, int[] nums2, int i, int j) {\n\n        // Base case: if either array is exhausted\n        if (i < 0 || j < 0) {\n            return Integer.MIN_VALUE; // invalid (non-empty constraint)\n        }\n\n        // If already computed, reuse it\n        if (dp[i][j] != null) {\n            return dp[i][j];\n        }\n\n        // Option 1: take current pair\n        int product = nums1[i] * nums2[j];\n\n        // Option 2: extend a previous subsequence\n        int extend = solve(nums1, nums2, i - 1, j - 1);\n        int take = product;\n        if (extend != Integer.MIN_VALUE) {\n            take = Math.max(take, product + extend);\n        }\n\n        // Option 3: skip one element\n        int skip = Math.max(\n            solve(nums1, nums2, i - 1, j),\n            solve(nums1, nums2, i, j - 1)\n        );\n\n        // Store and return the best result\n        return dp[i][j] = Math.max(take, skip);\n    }\n}",
        "readme": "DailyCodingChallengeCompleted!,CompletionStreak:,176,Days,Consistencyiskey,seeyoutomorrow!\n\nGiven two arrays nums1Â and nums2.\n\nReturn the maximum dot productÂ betweenÂ non-empty subsequences of nums1 and nums2 with the same length.\n\nA subsequence of a array is a new array which is formed from the original array by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie,Â [2,3,5]Â is a subsequence ofÂ [1,2,3,4,5]Â while [1,5,3]Â is not).\n\nÂ \nExample 1:\n\nInput: nums1 = [2,1,-2,5], nums2 = [3,0,-6]\nOutput: 18\nExplanation: Take subsequence [2,-2] from nums1 and subsequence [3,-6] from nums2.\nTheir dot product is (2*3 + (-2)*(-6)) = 18.\n\nExample 2:\n\nInput: nums1 = [3,-2], nums2 = [2,-6,7]\nOutput: 21\nExplanation: Take subsequence [3] from nums1 and subsequence [7] from nums2.\nTheir dot product is (3*7) = 21.\n\nExample 3:\n\nInput: nums1 = [-1,-1], nums2 = [1,1]\nOutput: -1\nExplanation: Take subsequence [-1] from nums1 and subsequence [1] from nums2.\nTheir dot product is -1.\n\nÂ \nConstraints:\n\n\n\t1 <= nums1.length, nums2.length <= 500\n\t-1000 <= nums1[i], nums2[i] <= 1000",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-08T05:38:27.000Z"
    },
    {
      "id": "leetcode-hard-maximal-rectangle",
      "platform": "Leetcode",
      "difficulty": "Hard",
      "problemName": "Maximal Rectangle",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int maximalRectangle(char[][] matrix) {\n        int m = matrix.length, n = matrix[0].length, ans = 0;\n        int[]hist = new int[n];\n\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(matrix[i][j]!='0')hist[j]+=1;\n                else hist[j] = 0;\n            }\n            int area = area(hist);\n            ans = Math.max(ans, area);\n        }\n\n        return ans;\n       \n    }\n\n    public static int area(int[] heights) {\n        int n = heights.length;\n        int maxArea = 0;\n        Stack<Integer> stack = new Stack<>();\n\n        for (int i = 0; i <= n; i++) {\n            int h = (i == n) ? 0 : heights[i];\n            while (!stack.isEmpty() && h < heights[stack.peek()]) {\n                int height = heights[stack.pop()];\n                int width = stack.isEmpty() ? i : i - stack.peek() - 1;\n                maxArea = Math.max(maxArea, height * width);\n            }\n            stack.push(i);\n        }\n\n        return maxArea;\n    }\n}",
        "readme": "DailyCodingChallengeCompleted!,CompletionStreak:,179,Days,Consistencyiskey,seeyoutomorrow!\n\nGiven a rows x colsÂ binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.\n\nÂ \nExample 1:\n\nInput: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\nOutput: 6\nExplanation: The maximal rectangle is shown in the above picture.\n\n\nExample 2:\n\nInput: matrix = [[\"0\"]]\nOutput: 0\n\n\nExample 3:\n\nInput: matrix = [[\"1\"]]\nOutput: 1\n\n\nÂ \nConstraints:\n\n\n\trows == matrix.length\n\tcols == matrix[i].length\n\t1 <= rows, cols <= 200\n\tmatrix[i][j] is '0' or '1'.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2026-01-11T14:18:18.000Z"
    },
    {
      "id": "leetcode-hard-separate-squares-ii",
      "platform": "Leetcode",
      "difficulty": "Hard",
      "problemName": "Separate Squares II",
      "language": "java",
      "files": {
        "code": "import java.util.*;\n\nclass Solution {\n    // Helper class to represent active X-intervals\n    private static class Interval implements Comparable<Interval> {\n        int start, end;\n        \n        Interval(int start, int end) {\n            this.start = start;\n            this.end = end;\n        }\n        \n        // Needed for sort\n        public int compareTo(Interval other) {\n            if (this.start != other.start) return Integer.compare(this.start, other.start);\n            return Integer.compare(this.end, other.end);\n        }\n\n        // Needed for removing specific objects from ArrayList\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Interval interval = (Interval) o;\n            return start == interval.start && end == interval.end;\n        }\n    }\n\n    // Helper class for Sweep Line events\n    private static class Event implements Comparable<Event> {\n        int y;\n        int type; // 1 for start, -1 for end\n        int xStart, xEnd;\n\n        Event(int y, int type, int xStart, int xEnd) {\n            this.y = y;\n            this.type = type;\n            this.xStart = xStart;\n            this.xEnd = xEnd;\n        }\n\n        public int compareTo(Event other) {\n            return Integer.compare(this.y, other.y);\n        }\n    }\n\n    public double separateSquares(int[][] squares) {\n        List<Event> sweepEvents = new ArrayList<>();\n        for (int[] sq : squares) {\n            int x = sq[0];\n            int y = sq[1];\n            int l = sq[2];\n            sweepEvents.add(new Event(y, 1, x, x + l));\n            sweepEvents.add(new Event(y + l, -1, x, x + l));\n        }\n\n        Collections.sort(sweepEvents);\n\n        List<Interval> activeIntervals = new ArrayList<>();\n        // Store strips as: [y_bottom, height, union_width]\n        List<double[]> processedStrips = new ArrayList<>();\n        \n        double totalArea = 0;\n        int prevY = sweepEvents.get(0).y;\n\n        for (Event event : sweepEvents) {\n            // Process the gap (strip) between the previous event and this one\n            if (event.y > prevY) {\n                double unionWidth = getUnionWidth(activeIntervals);\n                double height = (double) event.y - prevY;\n                \n                if (unionWidth > 0) {\n                    processedStrips.add(new double[]{prevY, height, unionWidth});\n                    totalArea += height * unionWidth;\n                }\n            }\n\n            // Update active intervals list\n            Interval currentInterval = new Interval(event.xStart, event.xEnd);\n            if (event.type == 1) {\n                activeIntervals.add(currentInterval);\n            } else {\n                activeIntervals.remove(currentInterval);\n            }\n            \n            prevY = event.y;\n        }\n\n        // Second Pass: Find the split point\n        double targetArea = totalArea / 2.0;\n        double accumulatedArea = 0;\n\n        for (double[] strip : processedStrips) {\n            double bottomY = strip[0];\n            double height = strip[1];\n            double width = strip[2];\n            double stripArea = height * width;\n\n            if (accumulatedArea + stripArea >= targetArea) {\n                double missingArea = targetArea - accumulatedArea;\n                return bottomY + (missingArea / width);\n            }\n            accumulatedArea += stripArea;\n        }\n\n        return 0.0;\n    }\n\n    // Brute force union width calculation: O(K log K) where K is active squares\n    private double getUnionWidth(List<Interval> intervals) {\n        if (intervals.isEmpty()) return 0;\n\n        // Create a copy to sort, so we don't mess up the main list order unnecessarily\n        List<Interval> sorted = new ArrayList<>(intervals);\n        Collections.sort(sorted);\n\n        double unionLength = 0;\n        double currentEnd = -1e18; // Negative infinity\n\n        for (Interval iv : sorted) {\n            if (iv.start >= currentEnd) {\n                // Disjoint interval\n                unionLength += (iv.end - iv.start);\n                currentEnd = iv.end;\n            } else if (iv.end > currentEnd) {\n                // Overlapping interval\n                unionLength += (iv.end - currentEnd);\n                currentEnd = iv.end;\n            }\n        }\n        return unionLength;\n    }\n}",
        "readme": "",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": false,
      "hasNotes": false,
      "lastUpdated": "2026-01-14T17:54:29.000Z"
    }
  ]
}